<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INF2990: Utilitaire</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">INF2990
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilitaire</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceaidecollision"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaidecollision.html">aidecollision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutilitaire"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilitaire.html">utilitaire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemath"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemath.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaidegl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaidegl.html">aidegl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemodele"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemodele.html">modele</a></td></tr>
<tr class="memdesc:namespacemodele"><td class="mdescLeft">&#160;</td><td class="mdescRight">Déclaration avancée de Assimp. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevue.html">vue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette classe contient des méthodes &lt; permettant d'écrire dans un fichier binaire des variables string, double, float, int, unsigned int, char, bool.  <a href="class_c_ecriture_fichier_binaire.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">cette classe contient des méthodes &gt; permettant de lire dans un fichier binaire des variables de types string, double, float, int, unsigned int, char, et bool.  <a href="class_c_lecture_fichier_binaire.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classe qui représente l'état des variables de la machine <a class="el" href="namespace_open_g_l.html">OpenGL</a>.  <a href="class_etat_open_g_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_singleton.html">Singleton&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette classe représente une base générique pour la déclaration de singleton.  <a href="class_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_matrix4x4t.html">aiMatrix4x4t&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae90f81f48642444b4ba7fa5cacf40569"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae90f81f48642444b4ba7fa5cacf40569">GL_CLAMP_TO_EDGE</a>&#160;&#160;&#160;0x812F</td></tr>
<tr class="separator:gae90f81f48642444b4ba7fa5cacf40569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c476dc47b86b4ef9ff111febf1e6c7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4c476dc47b86b4ef9ff111febf1e6c7f">VERTEX_LOCATION</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga4c476dc47b86b4ef9ff111febf1e6c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849df54224f798741d3fe046180dddfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga849df54224f798741d3fe046180dddfc">COMPARER_VALEUR</a>(x,  chaine)&#160;&#160;&#160;if (x == chaine) return #chaine ;</td></tr>
<tr class="memdesc:ga849df54224f798741d3fe046180dddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette macro permet de retourner la chaîne associée à une valeur.  <a href="#ga849df54224f798741d3fe046180dddfc">More...</a><br /></td></tr>
<tr class="separator:ga849df54224f798741d3fe046180dddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd82c66571930dca394095824ff37a5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gacd82c66571930dca394095824ff37a5c">COMPARER_DEFAUT</a>(x)&#160;&#160;&#160;return &quot;GL_??? (&quot; + utilitaire::convertirEnChaine(x) + &quot;)&quot;;</td></tr>
<tr class="memdesc:gacd82c66571930dca394095824ff37a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette macro retourne la valeur par défaut de la variable.  <a href="#gacd82c66571930dca394095824ff37a5c">More...</a><br /></td></tr>
<tr class="separator:gacd82c66571930dca394095824ff37a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4ee9d5709f277c392eea80755d85d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1e4ee9d5709f277c392eea80755d85d0">SINGLETON_DECLARATION_CLASSE</a>(Classe)</td></tr>
<tr class="separator:ga1e4ee9d5709f277c392eea80755d85d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5462d4b058b18eaee177c1f3f50964"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4e5462d4b058b18eaee177c1f3f50964">SINGLETON_DECLARATION_CLASSE_SANS_CONSTRUCTEUR</a>(Classe)</td></tr>
<tr class="separator:ga4e5462d4b058b18eaee177c1f3f50964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd88a0bb7182bc9164ab9200f31e6340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafd88a0bb7182bc9164ab9200f31e6340">SINGLETON_DECLARATION_CPP</a>(Classe)&#160;&#160;&#160;Classe * <a class="el" href="class_singleton.html">Singleton</a>&lt; Classe &gt;::instance_{ nullptr }; \</td></tr>
<tr class="separator:gafd88a0bb7182bc9164ab9200f31e6340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f918755b601cf4bffca775992e6fb90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9f918755b601cf4bffca775992e6fb90">NOMINMAX</a></td></tr>
<tr class="memdesc:ga9f918755b601cf4bffca775992e6fb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force à ne pas inclure les macros min et max de windows.h.  <a href="#ga9f918755b601cf4bffca775992e6fb90">More...</a><br /></td></tr>
<tr class="separator:ga9f918755b601cf4bffca775992e6fb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga53988236a3db0c0faa5eb1d8aa6a0742"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga53988236a3db0c0faa5eb1d8aa6a0742">aiMatrix4x4</a> = <a class="el" href="classai_matrix4x4t.html">aiMatrix4x4t</a>&lt; float &gt;</td></tr>
<tr class="memdesc:ga53988236a3db0c0faa5eb1d8aa6a0742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Déclaration avancée d'une classe.  <a href="#ga53988236a3db0c0faa5eb1d8aa6a0742">More...</a><br /></td></tr>
<tr class="separator:ga53988236a3db0c0faa5eb1d8aa6a0742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3eb1e87955cdb70cd0b16f217740326b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3eb1e87955cdb70cd0b16f217740326b">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const std::string &amp;s)</td></tr>
<tr class="separator:ga3eb1e87955cdb70cd0b16f217740326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04922202c65ecfea992b139fa3ad19ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga04922202c65ecfea992b139fa3ad19ff">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const double &amp;x)</td></tr>
<tr class="separator:ga04922202c65ecfea992b139fa3ad19ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga616de7f95d66959d1a2e3216143180aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga616de7f95d66959d1a2e3216143180aa">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const float &amp;x)</td></tr>
<tr class="separator:ga616de7f95d66959d1a2e3216143180aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0af1c4869b15575ea9c9567a377776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1c0af1c4869b15575ea9c9567a377776">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const int &amp;x)</td></tr>
<tr class="separator:ga1c0af1c4869b15575ea9c9567a377776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c96e2902dbd2e7fc766683ae7dd3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa4c96e2902dbd2e7fc766683ae7dd3a0">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const unsigned int &amp;x)</td></tr>
<tr class="separator:gaa4c96e2902dbd2e7fc766683ae7dd3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df50a83cca6bbfec35053d1b3f08a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2df50a83cca6bbfec35053d1b3f08a83">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const char &amp;x)</td></tr>
<tr class="separator:ga2df50a83cca6bbfec35053d1b3f08a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7baf907cb1eec95df25008219c34f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5e7baf907cb1eec95df25008219c34f7">operator&lt;</a> (<a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;out, const bool &amp;x)</td></tr>
<tr class="separator:ga5e7baf907cb1eec95df25008219c34f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga810bf15b405f05f3069b97084f61aa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga810bf15b405f05f3069b97084f61aa95">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;in, std::string &amp;s)</td></tr>
<tr class="separator:ga810bf15b405f05f3069b97084f61aa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3286b1bfce354ab81b9c5e16318f3726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3286b1bfce354ab81b9c5e16318f3726">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;in, double &amp;f)</td></tr>
<tr class="separator:ga3286b1bfce354ab81b9c5e16318f3726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a0bc917393930593341bc27a7fa51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga66a0bc917393930593341bc27a7fa51d">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;in, float &amp;f)</td></tr>
<tr class="separator:ga66a0bc917393930593341bc27a7fa51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cd33d9234f45523dd443b122d897fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga06cd33d9234f45523dd443b122d897fa">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;in, int &amp;f)</td></tr>
<tr class="separator:ga06cd33d9234f45523dd443b122d897fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02d6718459c6e38d1ef0350b209da02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf02d6718459c6e38d1ef0350b209da02">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;in, unsigned int &amp;f)</td></tr>
<tr class="separator:gaf02d6718459c6e38d1ef0350b209da02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81285ae431b1fa84429945395a36f8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga81285ae431b1fa84429945395a36f8ce">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;in, char &amp;f)</td></tr>
<tr class="separator:ga81285ae431b1fa84429945395a36f8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1585cce945bae21c66998f92f175b115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1585cce945bae21c66998f92f175b115">operator&gt;</a> (<a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;in, bool &amp;f)</td></tr>
<tr class="separator:ga1585cce945bae21c66998f92f175b115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07715cf8ba84aab7a025770804188a24"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga07715cf8ba84aab7a025770804188a24">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;etat)</td></tr>
<tr class="separator:ga07715cf8ba84aab7a025770804188a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5846202001fecd71cd2a0afbbdb494"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5b5846202001fecd71cd2a0afbbdb494">CEcritureFichierBinaire::CEcritureFichierBinaire</a> ()</td></tr>
<tr class="memdesc:ga5b5846202001fecd71cd2a0afbbdb494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut.  <a href="#ga5b5846202001fecd71cd2a0afbbdb494">More...</a><br /></td></tr>
<tr class="separator:ga5b5846202001fecd71cd2a0afbbdb494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19b9753aa12a9f25fd0febc3c899024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad19b9753aa12a9f25fd0febc3c899024">CEcritureFichierBinaire::CEcritureFichierBinaire</a> (const char *nomFichier, openmode mode=std::ios::out|std::ios::binary)</td></tr>
<tr class="memdesc:gad19b9753aa12a9f25fd0febc3c899024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par paramètre.  <a href="#gad19b9753aa12a9f25fd0febc3c899024">More...</a><br /></td></tr>
<tr class="separator:gad19b9753aa12a9f25fd0febc3c899024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7145545254c30909311d3b1ef0bdd07a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7145545254c30909311d3b1ef0bdd07a">CEcritureFichierBinaire::null</a> (int n)</td></tr>
<tr class="memdesc:ga7145545254c30909311d3b1ef0bdd07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction pour insérer des caractères vides dans le fichier.  <a href="#ga7145545254c30909311d3b1ef0bdd07a">More...</a><br /></td></tr>
<tr class="separator:ga7145545254c30909311d3b1ef0bdd07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a259905a2c14513846e6ecb8cf476ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3a259905a2c14513846e6ecb8cf476ad">CLectureFichierBinaire::CLectureFichierBinaire</a> ()</td></tr>
<tr class="memdesc:ga3a259905a2c14513846e6ecb8cf476ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut.  <a href="#ga3a259905a2c14513846e6ecb8cf476ad">More...</a><br /></td></tr>
<tr class="separator:ga3a259905a2c14513846e6ecb8cf476ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16ebab7b172408c2ba14605f61f0f84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac16ebab7b172408c2ba14605f61f0f84">CLectureFichierBinaire::CLectureFichierBinaire</a> (const char *nomFichier, openmode mode=std::ios::in|std::ios::binary)</td></tr>
<tr class="memdesc:gac16ebab7b172408c2ba14605f61f0f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par paramètre.  <a href="#gac16ebab7b172408c2ba14605f61f0f84">More...</a><br /></td></tr>
<tr class="separator:gac16ebab7b172408c2ba14605f61f0f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf682f61929f2502b08b6b88de07349b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf682f61929f2502b08b6b88de07349b6">EtatOpenGL::EtatOpenGL</a> ()</td></tr>
<tr class="memdesc:gaf682f61929f2502b08b6b88de07349b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut.  <a href="#gaf682f61929f2502b08b6b88de07349b6">More...</a><br /></td></tr>
<tr class="separator:gaf682f61929f2502b08b6b88de07349b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ddfdab3e65cc4069b86ba84d3f565b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga24ddfdab3e65cc4069b86ba84d3f565b">EtatOpenGL::obtenirDifference</a> (std::ostream &amp;o, const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;etat1, const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;etat2)</td></tr>
<tr class="memdesc:ga24ddfdab3e65cc4069b86ba84d3f565b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare deux états <a class="el" href="namespace_open_g_l.html">OpenGL</a> et affiche la différence entre les deux.  <a href="#ga24ddfdab3e65cc4069b86ba84d3f565b">More...</a><br /></td></tr>
<tr class="separator:ga24ddfdab3e65cc4069b86ba84d3f565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8656cbeda0f2ed712d9011abf508e57"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa8656cbeda0f2ed712d9011abf508e57">EtatOpenGL::obtenirChaineGlAccumAlphaBits</a> () const</td></tr>
<tr class="memdesc:gaa8656cbeda0f2ed712d9011abf508e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ACCUM_ALPHA_BITS.  <a href="#gaa8656cbeda0f2ed712d9011abf508e57">More...</a><br /></td></tr>
<tr class="separator:gaa8656cbeda0f2ed712d9011abf508e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbb4a62b0b523eeedca913830f31f1b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7dbb4a62b0b523eeedca913830f31f1b">EtatOpenGL::obtenirChaineGlAccumBlueBits</a> () const</td></tr>
<tr class="memdesc:ga7dbb4a62b0b523eeedca913830f31f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ACCUM_BLUE_BITS.  <a href="#ga7dbb4a62b0b523eeedca913830f31f1b">More...</a><br /></td></tr>
<tr class="separator:ga7dbb4a62b0b523eeedca913830f31f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8c270275c56c28b245cdfd36382564"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafd8c270275c56c28b245cdfd36382564">EtatOpenGL::obtenirChaineGlAccumClearValue</a> () const</td></tr>
<tr class="memdesc:gafd8c270275c56c28b245cdfd36382564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ACCUM_CLEAR_VALUE.  <a href="#gafd8c270275c56c28b245cdfd36382564">More...</a><br /></td></tr>
<tr class="separator:gafd8c270275c56c28b245cdfd36382564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad3c3edbf3e81b25319385d46ec27a4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5ad3c3edbf3e81b25319385d46ec27a4">EtatOpenGL::obtenirChaineGlAccumGreenBits</a> () const</td></tr>
<tr class="memdesc:ga5ad3c3edbf3e81b25319385d46ec27a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ACCUM_GREEN_BITS.  <a href="#ga5ad3c3edbf3e81b25319385d46ec27a4">More...</a><br /></td></tr>
<tr class="separator:ga5ad3c3edbf3e81b25319385d46ec27a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993cdc1ff7f7e5455208a48872f8b60a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga993cdc1ff7f7e5455208a48872f8b60a">EtatOpenGL::obtenirChaineGlAccumRedBits</a> () const</td></tr>
<tr class="memdesc:ga993cdc1ff7f7e5455208a48872f8b60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ACCUM_RED_BITS.  <a href="#ga993cdc1ff7f7e5455208a48872f8b60a">More...</a><br /></td></tr>
<tr class="separator:ga993cdc1ff7f7e5455208a48872f8b60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c4d8c91afe67877586b679872dc623"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga46c4d8c91afe67877586b679872dc623">EtatOpenGL::obtenirChaineGlAlphaBias</a> () const</td></tr>
<tr class="memdesc:ga46c4d8c91afe67877586b679872dc623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ALPHA_BIAS.  <a href="#ga46c4d8c91afe67877586b679872dc623">More...</a><br /></td></tr>
<tr class="separator:ga46c4d8c91afe67877586b679872dc623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ad2bee7735604cafceab92693f9e11"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad2ad2bee7735604cafceab92693f9e11">EtatOpenGL::obtenirChaineGlAlphaBits</a> () const</td></tr>
<tr class="memdesc:gad2ad2bee7735604cafceab92693f9e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ALPHA_BITS.  <a href="#gad2ad2bee7735604cafceab92693f9e11">More...</a><br /></td></tr>
<tr class="separator:gad2ad2bee7735604cafceab92693f9e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9954ff46bf1c58149d829b76f8db41"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaae9954ff46bf1c58149d829b76f8db41">EtatOpenGL::obtenirChaineGlAlphaScale</a> () const</td></tr>
<tr class="memdesc:gaae9954ff46bf1c58149d829b76f8db41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ALPHA_SCALE.  <a href="#gaae9954ff46bf1c58149d829b76f8db41">More...</a><br /></td></tr>
<tr class="separator:gaae9954ff46bf1c58149d829b76f8db41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2625ee169f3e5c1c23340fd1a2b7d4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7b2625ee169f3e5c1c23340fd1a2b7d4">EtatOpenGL::obtenirChaineGlAlphaTest</a> () const</td></tr>
<tr class="memdesc:ga7b2625ee169f3e5c1c23340fd1a2b7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ALPHA_TEST.  <a href="#ga7b2625ee169f3e5c1c23340fd1a2b7d4">More...</a><br /></td></tr>
<tr class="separator:ga7b2625ee169f3e5c1c23340fd1a2b7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde25f2a3f9f1498b01b0b1c6ead8cd6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gabde25f2a3f9f1498b01b0b1c6ead8cd6">EtatOpenGL::obtenirChaineGlAlphaTestFunc</a> () const</td></tr>
<tr class="memdesc:gabde25f2a3f9f1498b01b0b1c6ead8cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ALPHA_TEST_FUNC.  <a href="#gabde25f2a3f9f1498b01b0b1c6ead8cd6">More...</a><br /></td></tr>
<tr class="separator:gabde25f2a3f9f1498b01b0b1c6ead8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8100b417d2a68024951ae1870e3c8ce9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8100b417d2a68024951ae1870e3c8ce9">EtatOpenGL::obtenirChaineGlAlphaTestRef</a> () const</td></tr>
<tr class="memdesc:ga8100b417d2a68024951ae1870e3c8ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ALPHA_TEST_REF.  <a href="#ga8100b417d2a68024951ae1870e3c8ce9">More...</a><br /></td></tr>
<tr class="separator:ga8100b417d2a68024951ae1870e3c8ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ae7261196ab97cafdee0bd8f388814"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga05ae7261196ab97cafdee0bd8f388814">EtatOpenGL::obtenirChaineGlAttribStackDepth</a> () const</td></tr>
<tr class="memdesc:ga05ae7261196ab97cafdee0bd8f388814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ATTRIB_STACK_DEPTH.  <a href="#ga05ae7261196ab97cafdee0bd8f388814">More...</a><br /></td></tr>
<tr class="separator:ga05ae7261196ab97cafdee0bd8f388814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cb68c8068c33f061ba4e2f5a18fe58a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4cb68c8068c33f061ba4e2f5a18fe58a">EtatOpenGL::obtenirChaineGlAutoNormal</a> () const</td></tr>
<tr class="memdesc:ga4cb68c8068c33f061ba4e2f5a18fe58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_AUTO_NORMAL.  <a href="#ga4cb68c8068c33f061ba4e2f5a18fe58a">More...</a><br /></td></tr>
<tr class="separator:ga4cb68c8068c33f061ba4e2f5a18fe58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f7ed9e063fd7cd322ead2b920ad76d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9f7ed9e063fd7cd322ead2b920ad76d3">EtatOpenGL::obtenirChaineGlAuxBuffers</a> () const</td></tr>
<tr class="memdesc:ga9f7ed9e063fd7cd322ead2b920ad76d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_AUX_BUFFERS.  <a href="#ga9f7ed9e063fd7cd322ead2b920ad76d3">More...</a><br /></td></tr>
<tr class="separator:ga9f7ed9e063fd7cd322ead2b920ad76d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2714438ed8a3bbcfae6788452c41fc2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad2714438ed8a3bbcfae6788452c41fc2">EtatOpenGL::obtenirChaineGlBlend</a> () const</td></tr>
<tr class="memdesc:gad2714438ed8a3bbcfae6788452c41fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_BLEND.  <a href="#gad2714438ed8a3bbcfae6788452c41fc2">More...</a><br /></td></tr>
<tr class="separator:gad2714438ed8a3bbcfae6788452c41fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1d97b60cea47ff94c43cb7fe5549de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7e1d97b60cea47ff94c43cb7fe5549de">EtatOpenGL::obtenirChaineGlBlendDst</a> () const</td></tr>
<tr class="memdesc:ga7e1d97b60cea47ff94c43cb7fe5549de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_BLEND_DST.  <a href="#ga7e1d97b60cea47ff94c43cb7fe5549de">More...</a><br /></td></tr>
<tr class="separator:ga7e1d97b60cea47ff94c43cb7fe5549de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f762cf26215a0596f0f1e199054a6a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga72f762cf26215a0596f0f1e199054a6a">EtatOpenGL::obtenirChaineGlBlendSrc</a> () const</td></tr>
<tr class="memdesc:ga72f762cf26215a0596f0f1e199054a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_BLEND_SRC.  <a href="#ga72f762cf26215a0596f0f1e199054a6a">More...</a><br /></td></tr>
<tr class="separator:ga72f762cf26215a0596f0f1e199054a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac365fb32df160a1c96a2a83a1c366c6a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac365fb32df160a1c96a2a83a1c366c6a">EtatOpenGL::obtenirChaineGlBlueBias</a> () const</td></tr>
<tr class="memdesc:gac365fb32df160a1c96a2a83a1c366c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_BLUE_BIAS.  <a href="#gac365fb32df160a1c96a2a83a1c366c6a">More...</a><br /></td></tr>
<tr class="separator:gac365fb32df160a1c96a2a83a1c366c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256b4aa3305c8c45df1d1e69e9371251"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga256b4aa3305c8c45df1d1e69e9371251">EtatOpenGL::obtenirChaineGlBlueBits</a> () const</td></tr>
<tr class="memdesc:ga256b4aa3305c8c45df1d1e69e9371251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_BLUE_BITS.  <a href="#ga256b4aa3305c8c45df1d1e69e9371251">More...</a><br /></td></tr>
<tr class="separator:ga256b4aa3305c8c45df1d1e69e9371251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1705991ab059f889107b13b6d2143309"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1705991ab059f889107b13b6d2143309">EtatOpenGL::obtenirChaineGlBlueScale</a> () const</td></tr>
<tr class="memdesc:ga1705991ab059f889107b13b6d2143309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_BLUE_SCALE.  <a href="#ga1705991ab059f889107b13b6d2143309">More...</a><br /></td></tr>
<tr class="separator:ga1705991ab059f889107b13b6d2143309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7118bfe505a235920434b0b9b0ddb5f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab7118bfe505a235920434b0b9b0ddb5f">EtatOpenGL::obtenirChaineGlClientAttribStackDepth</a> () const</td></tr>
<tr class="memdesc:gab7118bfe505a235920434b0b9b0ddb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH.  <a href="#gab7118bfe505a235920434b0b9b0ddb5f">More...</a><br /></td></tr>
<tr class="separator:gab7118bfe505a235920434b0b9b0ddb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd5df42f81d3138c7a5740a3ccf8e11"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4bd5df42f81d3138c7a5740a3ccf8e11">EtatOpenGL::obtenirChaineGlClipPlanei</a> () const</td></tr>
<tr class="memdesc:ga4bd5df42f81d3138c7a5740a3ccf8e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CLIP_PLANEi.  <a href="#ga4bd5df42f81d3138c7a5740a3ccf8e11">More...</a><br /></td></tr>
<tr class="separator:ga4bd5df42f81d3138c7a5740a3ccf8e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3286196d8d748b5d71d60edac17e28be"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3286196d8d748b5d71d60edac17e28be">EtatOpenGL::obtenirChaineGlColorArray</a> () const</td></tr>
<tr class="memdesc:ga3286196d8d748b5d71d60edac17e28be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY.  <a href="#ga3286196d8d748b5d71d60edac17e28be">More...</a><br /></td></tr>
<tr class="separator:ga3286196d8d748b5d71d60edac17e28be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10b04c597d6737e387389bebf9d6ca7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac10b04c597d6737e387389bebf9d6ca7">EtatOpenGL::obtenirChaineGlColorArraySize</a> () const</td></tr>
<tr class="memdesc:gac10b04c597d6737e387389bebf9d6ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_SIZE.  <a href="#gac10b04c597d6737e387389bebf9d6ca7">More...</a><br /></td></tr>
<tr class="separator:gac10b04c597d6737e387389bebf9d6ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca446a9fe965203bf9dbc42d4864f0a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3ca446a9fe965203bf9dbc42d4864f0a">EtatOpenGL::obtenirChaineGlColorArrayStride</a> () const</td></tr>
<tr class="memdesc:ga3ca446a9fe965203bf9dbc42d4864f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_STRIDE.  <a href="#ga3ca446a9fe965203bf9dbc42d4864f0a">More...</a><br /></td></tr>
<tr class="separator:ga3ca446a9fe965203bf9dbc42d4864f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad413af6e274e71639b0d6835c7b7c2bd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad413af6e274e71639b0d6835c7b7c2bd">EtatOpenGL::obtenirChaineGlColorArrayType</a> () const</td></tr>
<tr class="memdesc:gad413af6e274e71639b0d6835c7b7c2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_TYPE.  <a href="#gad413af6e274e71639b0d6835c7b7c2bd">More...</a><br /></td></tr>
<tr class="separator:gad413af6e274e71639b0d6835c7b7c2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae0db2c8013a921e847549ade2c0ca6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaaae0db2c8013a921e847549ade2c0ca6">EtatOpenGL::obtenirChaineGlColorClearValue</a> () const</td></tr>
<tr class="memdesc:gaaae0db2c8013a921e847549ade2c0ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_COLOR_CLEAR_VALUE.  <a href="#gaaae0db2c8013a921e847549ade2c0ca6">More...</a><br /></td></tr>
<tr class="separator:gaaae0db2c8013a921e847549ade2c0ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee252aa711178229a58d3fd6c43c5de2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaee252aa711178229a58d3fd6c43c5de2">EtatOpenGL::obtenirChaineGlColorLogicOp</a> () const</td></tr>
<tr class="memdesc:gaee252aa711178229a58d3fd6c43c5de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_COLOR_LOGIC_OP.  <a href="#gaee252aa711178229a58d3fd6c43c5de2">More...</a><br /></td></tr>
<tr class="separator:gaee252aa711178229a58d3fd6c43c5de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e1deb995eafcfa552e9be15e08505a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga59e1deb995eafcfa552e9be15e08505a">EtatOpenGL::obtenirChaineGlColorWritemask</a> () const</td></tr>
<tr class="memdesc:ga59e1deb995eafcfa552e9be15e08505a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_COLOR_WRITEMASK.  <a href="#ga59e1deb995eafcfa552e9be15e08505a">More...</a><br /></td></tr>
<tr class="separator:ga59e1deb995eafcfa552e9be15e08505a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93ae0b0eca875fc037af17b44555072"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad93ae0b0eca875fc037af17b44555072">EtatOpenGL::obtenirChaineGlCullFace</a> () const</td></tr>
<tr class="memdesc:gad93ae0b0eca875fc037af17b44555072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CULL_FACE.  <a href="#gad93ae0b0eca875fc037af17b44555072">More...</a><br /></td></tr>
<tr class="separator:gad93ae0b0eca875fc037af17b44555072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b60c9393c3457e1107ad7ec1f8d062"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga94b60c9393c3457e1107ad7ec1f8d062">EtatOpenGL::obtenirChaineGlCullFaceMode</a> () const</td></tr>
<tr class="memdesc:ga94b60c9393c3457e1107ad7ec1f8d062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CULL_FACE_MODE.  <a href="#ga94b60c9393c3457e1107ad7ec1f8d062">More...</a><br /></td></tr>
<tr class="separator:ga94b60c9393c3457e1107ad7ec1f8d062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20884239fb1a60946172566ca0bca365"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga20884239fb1a60946172566ca0bca365">EtatOpenGL::obtenirChaineGlCurrentColor</a> () const</td></tr>
<tr class="memdesc:ga20884239fb1a60946172566ca0bca365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_COLOR.  <a href="#ga20884239fb1a60946172566ca0bca365">More...</a><br /></td></tr>
<tr class="separator:ga20884239fb1a60946172566ca0bca365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe68db66d3915cd5f0f77d538acf2a6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaabe68db66d3915cd5f0f77d538acf2a6">EtatOpenGL::obtenirChaineGlCurrentIndex</a> () const</td></tr>
<tr class="memdesc:gaabe68db66d3915cd5f0f77d538acf2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_INDEX.  <a href="#gaabe68db66d3915cd5f0f77d538acf2a6">More...</a><br /></td></tr>
<tr class="separator:gaabe68db66d3915cd5f0f77d538acf2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75bf3164a953e74dc9326e90cf7c8d85"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga75bf3164a953e74dc9326e90cf7c8d85">EtatOpenGL::obtenirChaineGlCurrentNormal</a> () const</td></tr>
<tr class="memdesc:ga75bf3164a953e74dc9326e90cf7c8d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_NORMAL.  <a href="#ga75bf3164a953e74dc9326e90cf7c8d85">More...</a><br /></td></tr>
<tr class="separator:ga75bf3164a953e74dc9326e90cf7c8d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3314105ec05d0f70813c7e9ec0e38640"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3314105ec05d0f70813c7e9ec0e38640">EtatOpenGL::obtenirChaineGlCurrentRasterColor</a> () const</td></tr>
<tr class="memdesc:ga3314105ec05d0f70813c7e9ec0e38640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_COLOR.  <a href="#ga3314105ec05d0f70813c7e9ec0e38640">More...</a><br /></td></tr>
<tr class="separator:ga3314105ec05d0f70813c7e9ec0e38640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbbc64055237c25eb1e48f3c72bcd049"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gadbbc64055237c25eb1e48f3c72bcd049">EtatOpenGL::obtenirChaineGlCurrentRasterDistance</a> () const</td></tr>
<tr class="memdesc:gadbbc64055237c25eb1e48f3c72bcd049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_DISTANCE.  <a href="#gadbbc64055237c25eb1e48f3c72bcd049">More...</a><br /></td></tr>
<tr class="separator:gadbbc64055237c25eb1e48f3c72bcd049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc3033052636dc0508fdaeefc900e24"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7cc3033052636dc0508fdaeefc900e24">EtatOpenGL::obtenirChaineGlCurrentRasterIndex</a> () const</td></tr>
<tr class="memdesc:ga7cc3033052636dc0508fdaeefc900e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_INDEX.  <a href="#ga7cc3033052636dc0508fdaeefc900e24">More...</a><br /></td></tr>
<tr class="separator:ga7cc3033052636dc0508fdaeefc900e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3dd2ee0e0ae262480c05c68a671c033"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae3dd2ee0e0ae262480c05c68a671c033">EtatOpenGL::obtenirChaineGlCurrentRasterPosition</a> () const</td></tr>
<tr class="memdesc:gae3dd2ee0e0ae262480c05c68a671c033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION.  <a href="#gae3dd2ee0e0ae262480c05c68a671c033">More...</a><br /></td></tr>
<tr class="separator:gae3dd2ee0e0ae262480c05c68a671c033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94408d6f73fe9c70c0460675bfe80e86"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga94408d6f73fe9c70c0460675bfe80e86">EtatOpenGL::obtenirChaineGlCurrentRasterPositionValid</a> () const</td></tr>
<tr class="memdesc:ga94408d6f73fe9c70c0460675bfe80e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION_VALID.  <a href="#ga94408d6f73fe9c70c0460675bfe80e86">More...</a><br /></td></tr>
<tr class="separator:ga94408d6f73fe9c70c0460675bfe80e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1517a5b7f85128f7975d2ed22f2a41a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae1517a5b7f85128f7975d2ed22f2a41a">EtatOpenGL::obtenirChaineGlCurrentRasterTextureCoords</a> () const</td></tr>
<tr class="memdesc:gae1517a5b7f85128f7975d2ed22f2a41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS.  <a href="#gae1517a5b7f85128f7975d2ed22f2a41a">More...</a><br /></td></tr>
<tr class="separator:gae1517a5b7f85128f7975d2ed22f2a41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d9dc43fb9d85437a9a14b9cfa8d404"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa1d9dc43fb9d85437a9a14b9cfa8d404">EtatOpenGL::obtenirChaineGlCurrentTextureCoords</a> () const</td></tr>
<tr class="memdesc:gaa1d9dc43fb9d85437a9a14b9cfa8d404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_CURRENT_TEXTURE_COORDS.  <a href="#gaa1d9dc43fb9d85437a9a14b9cfa8d404">More...</a><br /></td></tr>
<tr class="separator:gaa1d9dc43fb9d85437a9a14b9cfa8d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e04321a436f388c626d2f529c3c185"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga21e04321a436f388c626d2f529c3c185">EtatOpenGL::obtenirChaineGlDepthBias</a> () const</td></tr>
<tr class="memdesc:ga21e04321a436f388c626d2f529c3c185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_BIAS.  <a href="#ga21e04321a436f388c626d2f529c3c185">More...</a><br /></td></tr>
<tr class="separator:ga21e04321a436f388c626d2f529c3c185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0e44f1891bae7fc43c7a12a8b71fc52"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae0e44f1891bae7fc43c7a12a8b71fc52">EtatOpenGL::obtenirChaineGlDepthBits</a> () const</td></tr>
<tr class="memdesc:gae0e44f1891bae7fc43c7a12a8b71fc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_BITS.  <a href="#gae0e44f1891bae7fc43c7a12a8b71fc52">More...</a><br /></td></tr>
<tr class="separator:gae0e44f1891bae7fc43c7a12a8b71fc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9515e1564287dae37c509a4b17336c2d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9515e1564287dae37c509a4b17336c2d">EtatOpenGL::obtenirChaineGlDepthClearValue</a> () const</td></tr>
<tr class="memdesc:ga9515e1564287dae37c509a4b17336c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_CLEAR_VALUE.  <a href="#ga9515e1564287dae37c509a4b17336c2d">More...</a><br /></td></tr>
<tr class="separator:ga9515e1564287dae37c509a4b17336c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5bc5e5d75634f402e8f24d93e1caa1b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae5bc5e5d75634f402e8f24d93e1caa1b">EtatOpenGL::obtenirChaineGlDepthFunc</a> () const</td></tr>
<tr class="memdesc:gae5bc5e5d75634f402e8f24d93e1caa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_FUNC.  <a href="#gae5bc5e5d75634f402e8f24d93e1caa1b">More...</a><br /></td></tr>
<tr class="separator:gae5bc5e5d75634f402e8f24d93e1caa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e6a94d0619baaf53a89bbf2f550622"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga85e6a94d0619baaf53a89bbf2f550622">EtatOpenGL::obtenirChaineGlDepthRange</a> () const</td></tr>
<tr class="memdesc:ga85e6a94d0619baaf53a89bbf2f550622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_RANGE.  <a href="#ga85e6a94d0619baaf53a89bbf2f550622">More...</a><br /></td></tr>
<tr class="separator:ga85e6a94d0619baaf53a89bbf2f550622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7209dac0d5a1874b02c72e82c4d2c955"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7209dac0d5a1874b02c72e82c4d2c955">EtatOpenGL::obtenirChaineGlDepthScale</a> () const</td></tr>
<tr class="memdesc:ga7209dac0d5a1874b02c72e82c4d2c955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_SCALE.  <a href="#ga7209dac0d5a1874b02c72e82c4d2c955">More...</a><br /></td></tr>
<tr class="separator:ga7209dac0d5a1874b02c72e82c4d2c955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c24c37fa70752f2c69d4276ef849c97"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0c24c37fa70752f2c69d4276ef849c97">EtatOpenGL::obtenirChaineGlDepthTest</a> () const</td></tr>
<tr class="memdesc:ga0c24c37fa70752f2c69d4276ef849c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_TEST.  <a href="#ga0c24c37fa70752f2c69d4276ef849c97">More...</a><br /></td></tr>
<tr class="separator:ga0c24c37fa70752f2c69d4276ef849c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa77e7c295b2e35fa4d3fe85d30bce33a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa77e7c295b2e35fa4d3fe85d30bce33a">EtatOpenGL::obtenirChaineGlDepthWritemask</a> () const</td></tr>
<tr class="memdesc:gaa77e7c295b2e35fa4d3fe85d30bce33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DEPTH_WRITEMASK.  <a href="#gaa77e7c295b2e35fa4d3fe85d30bce33a">More...</a><br /></td></tr>
<tr class="separator:gaa77e7c295b2e35fa4d3fe85d30bce33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8275ab093f85a85e79ef7ccf1ba4a83"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad8275ab093f85a85e79ef7ccf1ba4a83">EtatOpenGL::obtenirChaineGlDither</a> () const</td></tr>
<tr class="memdesc:gad8275ab093f85a85e79ef7ccf1ba4a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DITHER.  <a href="#gad8275ab093f85a85e79ef7ccf1ba4a83">More...</a><br /></td></tr>
<tr class="separator:gad8275ab093f85a85e79ef7ccf1ba4a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad85cc7827f114c6477b91741e404c3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaad85cc7827f114c6477b91741e404c3a">EtatOpenGL::obtenirChaineGlDoublebuffer</a> () const</td></tr>
<tr class="memdesc:gaad85cc7827f114c6477b91741e404c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DOUBLEBUFFER.  <a href="#gaad85cc7827f114c6477b91741e404c3a">More...</a><br /></td></tr>
<tr class="separator:gaad85cc7827f114c6477b91741e404c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f97ba97f9f390b2cb307a2253e7817a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9f97ba97f9f390b2cb307a2253e7817a">EtatOpenGL::obtenirChaineGlDrawBuffer</a> () const</td></tr>
<tr class="memdesc:ga9f97ba97f9f390b2cb307a2253e7817a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_DRAW_BUFFER.  <a href="#ga9f97ba97f9f390b2cb307a2253e7817a">More...</a><br /></td></tr>
<tr class="separator:ga9f97ba97f9f390b2cb307a2253e7817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd6bd412fc0e4cc38ac7c146843a5b72"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gabd6bd412fc0e4cc38ac7c146843a5b72">EtatOpenGL::obtenirChaineGlEdgeFlag</a> () const</td></tr>
<tr class="memdesc:gabd6bd412fc0e4cc38ac7c146843a5b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_EDGE_FLAG.  <a href="#gabd6bd412fc0e4cc38ac7c146843a5b72">More...</a><br /></td></tr>
<tr class="separator:gabd6bd412fc0e4cc38ac7c146843a5b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ea8b2938944cc1a4e9dbb7a4ad5bce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga72ea8b2938944cc1a4e9dbb7a4ad5bce">EtatOpenGL::obtenirChaineGlEdgeFlagArray</a> () const</td></tr>
<tr class="memdesc:ga72ea8b2938944cc1a4e9dbb7a4ad5bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY.  <a href="#ga72ea8b2938944cc1a4e9dbb7a4ad5bce">More...</a><br /></td></tr>
<tr class="separator:ga72ea8b2938944cc1a4e9dbb7a4ad5bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab483fd765edeb5933dea413939b52a10"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab483fd765edeb5933dea413939b52a10">EtatOpenGL::obtenirChaineGlEdgeFlagArrayStride</a> () const</td></tr>
<tr class="memdesc:gab483fd765edeb5933dea413939b52a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE.  <a href="#gab483fd765edeb5933dea413939b52a10">More...</a><br /></td></tr>
<tr class="separator:gab483fd765edeb5933dea413939b52a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7753e66d86737b2a85d5e6f95fd4aea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf7753e66d86737b2a85d5e6f95fd4aea">EtatOpenGL::obtenirChaineGlFeedbackBufferSize</a> () const</td></tr>
<tr class="memdesc:gaf7753e66d86737b2a85d5e6f95fd4aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_SIZE.  <a href="#gaf7753e66d86737b2a85d5e6f95fd4aea">More...</a><br /></td></tr>
<tr class="separator:gaf7753e66d86737b2a85d5e6f95fd4aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814db73f45f9df7ccf50acc6e59bdaaf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga814db73f45f9df7ccf50acc6e59bdaaf">EtatOpenGL::obtenirChaineGlFeedbackBufferType</a> () const</td></tr>
<tr class="memdesc:ga814db73f45f9df7ccf50acc6e59bdaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_TYPE.  <a href="#ga814db73f45f9df7ccf50acc6e59bdaaf">More...</a><br /></td></tr>
<tr class="separator:ga814db73f45f9df7ccf50acc6e59bdaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e8d960775b0eb966c82afb9ddb52e0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac8e8d960775b0eb966c82afb9ddb52e0">EtatOpenGL::obtenirChaineGlFog</a> () const</td></tr>
<tr class="memdesc:gac8e8d960775b0eb966c82afb9ddb52e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG.  <a href="#gac8e8d960775b0eb966c82afb9ddb52e0">More...</a><br /></td></tr>
<tr class="separator:gac8e8d960775b0eb966c82afb9ddb52e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga784b74f0e9d60221fd19cc10b79bc69d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga784b74f0e9d60221fd19cc10b79bc69d">EtatOpenGL::obtenirChaineGlFogColor</a> () const</td></tr>
<tr class="memdesc:ga784b74f0e9d60221fd19cc10b79bc69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG_COLOR.  <a href="#ga784b74f0e9d60221fd19cc10b79bc69d">More...</a><br /></td></tr>
<tr class="separator:ga784b74f0e9d60221fd19cc10b79bc69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cd91f196312ca03714055d8157f000"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga60cd91f196312ca03714055d8157f000">EtatOpenGL::obtenirChaineGlFogDensity</a> () const</td></tr>
<tr class="memdesc:ga60cd91f196312ca03714055d8157f000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG_DENSITY.  <a href="#ga60cd91f196312ca03714055d8157f000">More...</a><br /></td></tr>
<tr class="separator:ga60cd91f196312ca03714055d8157f000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e6ae47c747ef2901079b883242a816c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5e6ae47c747ef2901079b883242a816c">EtatOpenGL::obtenirChaineGlFogEnd</a> () const</td></tr>
<tr class="memdesc:ga5e6ae47c747ef2901079b883242a816c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG_END.  <a href="#ga5e6ae47c747ef2901079b883242a816c">More...</a><br /></td></tr>
<tr class="separator:ga5e6ae47c747ef2901079b883242a816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e0463757220fb3c7578405fb59a6820"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6e0463757220fb3c7578405fb59a6820">EtatOpenGL::obtenirChaineGlFogHint</a> () const</td></tr>
<tr class="memdesc:ga6e0463757220fb3c7578405fb59a6820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG_HINT.  <a href="#ga6e0463757220fb3c7578405fb59a6820">More...</a><br /></td></tr>
<tr class="separator:ga6e0463757220fb3c7578405fb59a6820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad272f3a0b0f28ccc317f2a1e0b14855f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad272f3a0b0f28ccc317f2a1e0b14855f">EtatOpenGL::obtenirChaineGlFogIndex</a> () const</td></tr>
<tr class="memdesc:gad272f3a0b0f28ccc317f2a1e0b14855f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG_INDEX.  <a href="#gad272f3a0b0f28ccc317f2a1e0b14855f">More...</a><br /></td></tr>
<tr class="separator:gad272f3a0b0f28ccc317f2a1e0b14855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a79598a8474e1708000380deb7dd7f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga04a79598a8474e1708000380deb7dd7f">EtatOpenGL::obtenirChaineGlFogMode</a> () const</td></tr>
<tr class="memdesc:ga04a79598a8474e1708000380deb7dd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG_MODE.  <a href="#ga04a79598a8474e1708000380deb7dd7f">More...</a><br /></td></tr>
<tr class="separator:ga04a79598a8474e1708000380deb7dd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa12c7dcadecd93fb0b8341ae0757cdf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafa12c7dcadecd93fb0b8341ae0757cdf">EtatOpenGL::obtenirChaineGlFogStart</a> () const</td></tr>
<tr class="memdesc:gafa12c7dcadecd93fb0b8341ae0757cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FOG_START.  <a href="#gafa12c7dcadecd93fb0b8341ae0757cdf">More...</a><br /></td></tr>
<tr class="separator:gafa12c7dcadecd93fb0b8341ae0757cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5efc4362a72db2431bf2d2e7bac4d977"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5efc4362a72db2431bf2d2e7bac4d977">EtatOpenGL::obtenirChaineGlFrontFace</a> () const</td></tr>
<tr class="memdesc:ga5efc4362a72db2431bf2d2e7bac4d977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_FRONT_FACE.  <a href="#ga5efc4362a72db2431bf2d2e7bac4d977">More...</a><br /></td></tr>
<tr class="separator:ga5efc4362a72db2431bf2d2e7bac4d977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840850c6c20df7baa91e455f762f70f1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga840850c6c20df7baa91e455f762f70f1">EtatOpenGL::obtenirChaineGlGreenBias</a> () const</td></tr>
<tr class="memdesc:ga840850c6c20df7baa91e455f762f70f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_GREEN_BIAS.  <a href="#ga840850c6c20df7baa91e455f762f70f1">More...</a><br /></td></tr>
<tr class="separator:ga840850c6c20df7baa91e455f762f70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00241b05a45ab2c548b32e19f260765"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab00241b05a45ab2c548b32e19f260765">EtatOpenGL::obtenirChaineGlGreenBits</a> () const</td></tr>
<tr class="memdesc:gab00241b05a45ab2c548b32e19f260765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_GREEN_BITS.  <a href="#gab00241b05a45ab2c548b32e19f260765">More...</a><br /></td></tr>
<tr class="separator:gab00241b05a45ab2c548b32e19f260765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d85fd92f39ab3e1127d793ed6bd544"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga89d85fd92f39ab3e1127d793ed6bd544">EtatOpenGL::obtenirChaineGlGreenScale</a> () const</td></tr>
<tr class="memdesc:ga89d85fd92f39ab3e1127d793ed6bd544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_GREEN_SCALE.  <a href="#ga89d85fd92f39ab3e1127d793ed6bd544">More...</a><br /></td></tr>
<tr class="separator:ga89d85fd92f39ab3e1127d793ed6bd544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c6db97e881cd2c6c84a94cc7988a77"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa0c6db97e881cd2c6c84a94cc7988a77">EtatOpenGL::obtenirChaineGlIndexArray</a> () const</td></tr>
<tr class="memdesc:gaa0c6db97e881cd2c6c84a94cc7988a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_ARRAY.  <a href="#gaa0c6db97e881cd2c6c84a94cc7988a77">More...</a><br /></td></tr>
<tr class="separator:gaa0c6db97e881cd2c6c84a94cc7988a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06dc22d7c82113165287539883874cb5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga06dc22d7c82113165287539883874cb5">EtatOpenGL::obtenirChaineGlIndexArrayStride</a> () const</td></tr>
<tr class="memdesc:ga06dc22d7c82113165287539883874cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_ARRAY_STRIDE.  <a href="#ga06dc22d7c82113165287539883874cb5">More...</a><br /></td></tr>
<tr class="separator:ga06dc22d7c82113165287539883874cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a8715e0f8b2c26af13b7c72f91d3c3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga62a8715e0f8b2c26af13b7c72f91d3c3">EtatOpenGL::obtenirChaineGlIndexArrayType</a> () const</td></tr>
<tr class="memdesc:ga62a8715e0f8b2c26af13b7c72f91d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_ARRAY_TYPE.  <a href="#ga62a8715e0f8b2c26af13b7c72f91d3c3">More...</a><br /></td></tr>
<tr class="separator:ga62a8715e0f8b2c26af13b7c72f91d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95369618151bee71fe60a9b7b04ef794"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga95369618151bee71fe60a9b7b04ef794">EtatOpenGL::obtenirChaineGlIndexBits</a> () const</td></tr>
<tr class="memdesc:ga95369618151bee71fe60a9b7b04ef794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_BITS.  <a href="#ga95369618151bee71fe60a9b7b04ef794">More...</a><br /></td></tr>
<tr class="separator:ga95369618151bee71fe60a9b7b04ef794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3ab756b3c7fd8ad3ca83019559dfb6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7d3ab756b3c7fd8ad3ca83019559dfb6">EtatOpenGL::obtenirChaineGlIndexClearValue</a> () const</td></tr>
<tr class="memdesc:ga7d3ab756b3c7fd8ad3ca83019559dfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_CLEAR_VALUE.  <a href="#ga7d3ab756b3c7fd8ad3ca83019559dfb6">More...</a><br /></td></tr>
<tr class="separator:ga7d3ab756b3c7fd8ad3ca83019559dfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6fe84e8d9d4328d989ba8eea4028c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6a6fe84e8d9d4328d989ba8eea4028c1">EtatOpenGL::obtenirChaineGlIndexLogicOp</a> () const</td></tr>
<tr class="memdesc:ga6a6fe84e8d9d4328d989ba8eea4028c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_LOGIC_OP.  <a href="#ga6a6fe84e8d9d4328d989ba8eea4028c1">More...</a><br /></td></tr>
<tr class="separator:ga6a6fe84e8d9d4328d989ba8eea4028c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6bec756899c6ca51948747fd0ef688"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5d6bec756899c6ca51948747fd0ef688">EtatOpenGL::obtenirChaineGlIndexMode</a> () const</td></tr>
<tr class="memdesc:ga5d6bec756899c6ca51948747fd0ef688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_MODE.  <a href="#ga5d6bec756899c6ca51948747fd0ef688">More...</a><br /></td></tr>
<tr class="separator:ga5d6bec756899c6ca51948747fd0ef688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c2361922e4a390cb6ea98b899666a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga89c2361922e4a390cb6ea98b899666a1">EtatOpenGL::obtenirChaineGlIndexOffset</a> () const</td></tr>
<tr class="memdesc:ga89c2361922e4a390cb6ea98b899666a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_OFFSET.  <a href="#ga89c2361922e4a390cb6ea98b899666a1">More...</a><br /></td></tr>
<tr class="separator:ga89c2361922e4a390cb6ea98b899666a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024563c27e484b25158053c5d17d65ed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga024563c27e484b25158053c5d17d65ed">EtatOpenGL::obtenirChaineGlIndexShift</a> () const</td></tr>
<tr class="memdesc:ga024563c27e484b25158053c5d17d65ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_SHIFT.  <a href="#ga024563c27e484b25158053c5d17d65ed">More...</a><br /></td></tr>
<tr class="separator:ga024563c27e484b25158053c5d17d65ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf831e8c9f908dfad12a6fa59414e78"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4bf831e8c9f908dfad12a6fa59414e78">EtatOpenGL::obtenirChaineGlIndexWritemask</a> () const</td></tr>
<tr class="memdesc:ga4bf831e8c9f908dfad12a6fa59414e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_INDEX_WRITEMASK.  <a href="#ga4bf831e8c9f908dfad12a6fa59414e78">More...</a><br /></td></tr>
<tr class="separator:ga4bf831e8c9f908dfad12a6fa59414e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0d748f174bf87954aa5464ff7db4ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7f0d748f174bf87954aa5464ff7db4ef">EtatOpenGL::obtenirChaineGlLineSmooth</a> () const</td></tr>
<tr class="memdesc:ga7f0d748f174bf87954aa5464ff7db4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_SMOOTH.  <a href="#ga7f0d748f174bf87954aa5464ff7db4ef">More...</a><br /></td></tr>
<tr class="separator:ga7f0d748f174bf87954aa5464ff7db4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0eec8ecca1691b24b5ea90fc0a72aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gada0eec8ecca1691b24b5ea90fc0a72aa">EtatOpenGL::obtenirChaineGlLineSmoothHint</a> () const</td></tr>
<tr class="memdesc:gada0eec8ecca1691b24b5ea90fc0a72aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_SMOOTH_HINT.  <a href="#gada0eec8ecca1691b24b5ea90fc0a72aa">More...</a><br /></td></tr>
<tr class="separator:gada0eec8ecca1691b24b5ea90fc0a72aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ae8628605b7b1c223a724429e8cd08"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab7ae8628605b7b1c223a724429e8cd08">EtatOpenGL::obtenirChaineGlLineStipple</a> () const</td></tr>
<tr class="memdesc:gab7ae8628605b7b1c223a724429e8cd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_STIPPLE.  <a href="#gab7ae8628605b7b1c223a724429e8cd08">More...</a><br /></td></tr>
<tr class="separator:gab7ae8628605b7b1c223a724429e8cd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7098806792020c69e9249e534f3993de"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7098806792020c69e9249e534f3993de">EtatOpenGL::obtenirChaineGlLineStipplePattern</a> () const</td></tr>
<tr class="memdesc:ga7098806792020c69e9249e534f3993de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_STIPPLE_PATTERN.  <a href="#ga7098806792020c69e9249e534f3993de">More...</a><br /></td></tr>
<tr class="separator:ga7098806792020c69e9249e534f3993de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36a7d44eca63a5d7b4b4201137a5ec9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae36a7d44eca63a5d7b4b4201137a5ec9">EtatOpenGL::obtenirChaineGlLineStippleRepeat</a> () const</td></tr>
<tr class="memdesc:gae36a7d44eca63a5d7b4b4201137a5ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_STIPPLE_REPEAT.  <a href="#gae36a7d44eca63a5d7b4b4201137a5ec9">More...</a><br /></td></tr>
<tr class="separator:gae36a7d44eca63a5d7b4b4201137a5ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4e09903daa0907f3219edc0b54c3c7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0b4e09903daa0907f3219edc0b54c3c7">EtatOpenGL::obtenirChaineGlLineWidth</a> () const</td></tr>
<tr class="memdesc:ga0b4e09903daa0907f3219edc0b54c3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_WIDTH.  <a href="#ga0b4e09903daa0907f3219edc0b54c3c7">More...</a><br /></td></tr>
<tr class="separator:ga0b4e09903daa0907f3219edc0b54c3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8d43b3b084323284e0c6bd913b7a7e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4d8d43b3b084323284e0c6bd913b7a7e">EtatOpenGL::obtenirChaineGlLineWidthGranularity</a> () const</td></tr>
<tr class="memdesc:ga4d8d43b3b084323284e0c6bd913b7a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_WIDTH_GRANULARITY.  <a href="#ga4d8d43b3b084323284e0c6bd913b7a7e">More...</a><br /></td></tr>
<tr class="separator:ga4d8d43b3b084323284e0c6bd913b7a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4042aa940e64993edf0339e4fe439820"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4042aa940e64993edf0339e4fe439820">EtatOpenGL::obtenirChaineGllineWidthRange</a> () const</td></tr>
<tr class="memdesc:ga4042aa940e64993edf0339e4fe439820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LINE_WIDTH_RANGE.  <a href="#ga4042aa940e64993edf0339e4fe439820">More...</a><br /></td></tr>
<tr class="separator:ga4042aa940e64993edf0339e4fe439820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4ef418485c6ac5343bd41c892c6cbae"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab4ef418485c6ac5343bd41c892c6cbae">EtatOpenGL::obtenirChaineGlListBase</a> () const</td></tr>
<tr class="memdesc:gab4ef418485c6ac5343bd41c892c6cbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LIST_BASE.  <a href="#gab4ef418485c6ac5343bd41c892c6cbae">More...</a><br /></td></tr>
<tr class="separator:gab4ef418485c6ac5343bd41c892c6cbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce2c5d4c226c53e6e4463d5e7acf35b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1ce2c5d4c226c53e6e4463d5e7acf35b">EtatOpenGL::obtenirChaineGlListIndex</a> () const</td></tr>
<tr class="memdesc:ga1ce2c5d4c226c53e6e4463d5e7acf35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LIST_INDEX.  <a href="#ga1ce2c5d4c226c53e6e4463d5e7acf35b">More...</a><br /></td></tr>
<tr class="separator:ga1ce2c5d4c226c53e6e4463d5e7acf35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b35e6ae2e52f70bf4b5196178d7bb48"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3b35e6ae2e52f70bf4b5196178d7bb48">EtatOpenGL::obtenirChaineGlListMode</a> () const</td></tr>
<tr class="memdesc:ga3b35e6ae2e52f70bf4b5196178d7bb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LIST_MODE.  <a href="#ga3b35e6ae2e52f70bf4b5196178d7bb48">More...</a><br /></td></tr>
<tr class="separator:ga3b35e6ae2e52f70bf4b5196178d7bb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374518f129ade463e34210c34f4fe967"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga374518f129ade463e34210c34f4fe967">EtatOpenGL::obtenirChaineGlLogicOpMode</a> () const</td></tr>
<tr class="memdesc:ga374518f129ade463e34210c34f4fe967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_LOGIC_OP_MODE.  <a href="#ga374518f129ade463e34210c34f4fe967">More...</a><br /></td></tr>
<tr class="separator:ga374518f129ade463e34210c34f4fe967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57d144b053a1c99018cea2e39b3a909"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac57d144b053a1c99018cea2e39b3a909">EtatOpenGL::obtenirChaineGlMap1Color4</a> () const</td></tr>
<tr class="memdesc:gac57d144b053a1c99018cea2e39b3a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_COLOR_4.  <a href="#gac57d144b053a1c99018cea2e39b3a909">More...</a><br /></td></tr>
<tr class="separator:gac57d144b053a1c99018cea2e39b3a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf763362cd94b7724001337e1d41e12fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf763362cd94b7724001337e1d41e12fe">EtatOpenGL::obtenirChaineGlMap1GridDomain</a> () const</td></tr>
<tr class="memdesc:gaf763362cd94b7724001337e1d41e12fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_GRID_DOMAIN.  <a href="#gaf763362cd94b7724001337e1d41e12fe">More...</a><br /></td></tr>
<tr class="separator:gaf763362cd94b7724001337e1d41e12fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee60c16c6bdb624d5ebc846ea3639d7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8ee60c16c6bdb624d5ebc846ea3639d7">EtatOpenGL::obtenirChaineGlMap1GridSegments</a> () const</td></tr>
<tr class="memdesc:ga8ee60c16c6bdb624d5ebc846ea3639d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_GRID_SEGMENTS.  <a href="#ga8ee60c16c6bdb624d5ebc846ea3639d7">More...</a><br /></td></tr>
<tr class="separator:ga8ee60c16c6bdb624d5ebc846ea3639d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76838290be271e3afca8cbc5ead4370e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga76838290be271e3afca8cbc5ead4370e">EtatOpenGL::obtenirChaineGlMap1Index</a> () const</td></tr>
<tr class="memdesc:ga76838290be271e3afca8cbc5ead4370e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_INDEX.  <a href="#ga76838290be271e3afca8cbc5ead4370e">More...</a><br /></td></tr>
<tr class="separator:ga76838290be271e3afca8cbc5ead4370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30e5c538d408bc25a8fe2c3abe024e8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab30e5c538d408bc25a8fe2c3abe024e8">EtatOpenGL::obtenirChaineGlMap1Normal</a> () const</td></tr>
<tr class="memdesc:gab30e5c538d408bc25a8fe2c3abe024e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_NORMAL.  <a href="#gab30e5c538d408bc25a8fe2c3abe024e8">More...</a><br /></td></tr>
<tr class="separator:gab30e5c538d408bc25a8fe2c3abe024e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea983353723427a58f4fdefd471b1682"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaea983353723427a58f4fdefd471b1682">EtatOpenGL::obtenirChaineGlMap1TextureCoord1</a> () const</td></tr>
<tr class="memdesc:gaea983353723427a58f4fdefd471b1682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_1.  <a href="#gaea983353723427a58f4fdefd471b1682">More...</a><br /></td></tr>
<tr class="separator:gaea983353723427a58f4fdefd471b1682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90439930d97788a4e754adadfe08412f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga90439930d97788a4e754adadfe08412f">EtatOpenGL::obtenirChaineGlMap1TextureCoord2</a> () const</td></tr>
<tr class="memdesc:ga90439930d97788a4e754adadfe08412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_2.  <a href="#ga90439930d97788a4e754adadfe08412f">More...</a><br /></td></tr>
<tr class="separator:ga90439930d97788a4e754adadfe08412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7abe6d7b529d6e26162093c0224a832"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac7abe6d7b529d6e26162093c0224a832">EtatOpenGL::obtenirChaineGlMap1TextureCoord3</a> () const</td></tr>
<tr class="memdesc:gac7abe6d7b529d6e26162093c0224a832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_3.  <a href="#gac7abe6d7b529d6e26162093c0224a832">More...</a><br /></td></tr>
<tr class="separator:gac7abe6d7b529d6e26162093c0224a832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3fec09fca2e0c6de37560cd148744c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7a3fec09fca2e0c6de37560cd148744c">EtatOpenGL::obtenirChaineGlMap1TextureCoord4</a> () const</td></tr>
<tr class="memdesc:ga7a3fec09fca2e0c6de37560cd148744c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_4.  <a href="#ga7a3fec09fca2e0c6de37560cd148744c">More...</a><br /></td></tr>
<tr class="separator:ga7a3fec09fca2e0c6de37560cd148744c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3ed72498b4d68dbdbfe0e5a32e3a40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8f3ed72498b4d68dbdbfe0e5a32e3a40">EtatOpenGL::obtenirChaineGlMap1Vertex3</a> () const</td></tr>
<tr class="memdesc:ga8f3ed72498b4d68dbdbfe0e5a32e3a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_VERTEX_3.  <a href="#ga8f3ed72498b4d68dbdbfe0e5a32e3a40">More...</a><br /></td></tr>
<tr class="separator:ga8f3ed72498b4d68dbdbfe0e5a32e3a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2f5633ecf15a85b63296a1e40b9191"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2c2f5633ecf15a85b63296a1e40b9191">EtatOpenGL::obtenirChaineGlMap1Vertex4</a> () const</td></tr>
<tr class="memdesc:ga2c2f5633ecf15a85b63296a1e40b9191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP1_VERTEX_4.  <a href="#ga2c2f5633ecf15a85b63296a1e40b9191">More...</a><br /></td></tr>
<tr class="separator:ga2c2f5633ecf15a85b63296a1e40b9191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a9ce4cd7f51dd9c8cbd70894556dc0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga09a9ce4cd7f51dd9c8cbd70894556dc0">EtatOpenGL::obtenirChaineGlMap2Color4</a> () const</td></tr>
<tr class="memdesc:ga09a9ce4cd7f51dd9c8cbd70894556dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_COLOR_4.  <a href="#ga09a9ce4cd7f51dd9c8cbd70894556dc0">More...</a><br /></td></tr>
<tr class="separator:ga09a9ce4cd7f51dd9c8cbd70894556dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4590606ccae7cdf8e98a79d497af46e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4590606ccae7cdf8e98a79d497af46e6">EtatOpenGL::obtenirChaineGlMap2GridDomain</a> () const</td></tr>
<tr class="memdesc:ga4590606ccae7cdf8e98a79d497af46e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_GRID_DOMAIN.  <a href="#ga4590606ccae7cdf8e98a79d497af46e6">More...</a><br /></td></tr>
<tr class="separator:ga4590606ccae7cdf8e98a79d497af46e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga384b4ac4bf1f142fd5dc8ec88d2c85fc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga384b4ac4bf1f142fd5dc8ec88d2c85fc">EtatOpenGL::obtenirChaineGlMap2GridSegments</a> () const</td></tr>
<tr class="memdesc:ga384b4ac4bf1f142fd5dc8ec88d2c85fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_GRID_SEGMENTS.  <a href="#ga384b4ac4bf1f142fd5dc8ec88d2c85fc">More...</a><br /></td></tr>
<tr class="separator:ga384b4ac4bf1f142fd5dc8ec88d2c85fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd7235c16eff55a23f25adcbf710911"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0bd7235c16eff55a23f25adcbf710911">EtatOpenGL::obtenirChaineGlMap2Index</a> () const</td></tr>
<tr class="memdesc:ga0bd7235c16eff55a23f25adcbf710911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_INDEX.  <a href="#ga0bd7235c16eff55a23f25adcbf710911">More...</a><br /></td></tr>
<tr class="separator:ga0bd7235c16eff55a23f25adcbf710911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bbf15a19f4634a8257aeb9bb80eb20e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1bbf15a19f4634a8257aeb9bb80eb20e">EtatOpenGL::obtenirChaineGlMap2Normal</a> () const</td></tr>
<tr class="memdesc:ga1bbf15a19f4634a8257aeb9bb80eb20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_NORMAL.  <a href="#ga1bbf15a19f4634a8257aeb9bb80eb20e">More...</a><br /></td></tr>
<tr class="separator:ga1bbf15a19f4634a8257aeb9bb80eb20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bc858ecfeb91e6c841e6115a7082a6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga22bc858ecfeb91e6c841e6115a7082a6">EtatOpenGL::obtenirChaineGlMap2TextureCoord1</a> () const</td></tr>
<tr class="memdesc:ga22bc858ecfeb91e6c841e6115a7082a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_1.  <a href="#ga22bc858ecfeb91e6c841e6115a7082a6">More...</a><br /></td></tr>
<tr class="separator:ga22bc858ecfeb91e6c841e6115a7082a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccaee7cbb411052f0d37e6751df9d8ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaccaee7cbb411052f0d37e6751df9d8ce">EtatOpenGL::obtenirChaineGlMap2TextureCoord2</a> () const</td></tr>
<tr class="memdesc:gaccaee7cbb411052f0d37e6751df9d8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_2.  <a href="#gaccaee7cbb411052f0d37e6751df9d8ce">More...</a><br /></td></tr>
<tr class="separator:gaccaee7cbb411052f0d37e6751df9d8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878568aa4f6b5245643bfa8bb4867efd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga878568aa4f6b5245643bfa8bb4867efd">EtatOpenGL::obtenirChaineGlMap2TextureCoord3</a> () const</td></tr>
<tr class="memdesc:ga878568aa4f6b5245643bfa8bb4867efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_3.  <a href="#ga878568aa4f6b5245643bfa8bb4867efd">More...</a><br /></td></tr>
<tr class="separator:ga878568aa4f6b5245643bfa8bb4867efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e5bb4869d4267c0e02ea534a48d375"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf4e5bb4869d4267c0e02ea534a48d375">EtatOpenGL::obtenirChaineGlMap2TextureCoord4</a> () const</td></tr>
<tr class="memdesc:gaf4e5bb4869d4267c0e02ea534a48d375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_4.  <a href="#gaf4e5bb4869d4267c0e02ea534a48d375">More...</a><br /></td></tr>
<tr class="separator:gaf4e5bb4869d4267c0e02ea534a48d375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285c29858dbc4e903c5b4ff440db53e8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga285c29858dbc4e903c5b4ff440db53e8">EtatOpenGL::obtenirChaineGlMap2Vertex3</a> () const</td></tr>
<tr class="memdesc:ga285c29858dbc4e903c5b4ff440db53e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_VERTEX_3.  <a href="#ga285c29858dbc4e903c5b4ff440db53e8">More...</a><br /></td></tr>
<tr class="separator:ga285c29858dbc4e903c5b4ff440db53e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39656da920c0d8514997f80f6a9cba9c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga39656da920c0d8514997f80f6a9cba9c">EtatOpenGL::obtenirChaineGlMap2Vertex4</a> () const</td></tr>
<tr class="memdesc:ga39656da920c0d8514997f80f6a9cba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP2_VERTEX_4.  <a href="#ga39656da920c0d8514997f80f6a9cba9c">More...</a><br /></td></tr>
<tr class="separator:ga39656da920c0d8514997f80f6a9cba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d0322515459f98842327324d0df057"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa8d0322515459f98842327324d0df057">EtatOpenGL::obtenirChaineGlMapColor</a> () const</td></tr>
<tr class="memdesc:gaa8d0322515459f98842327324d0df057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP_COLOR.  <a href="#gaa8d0322515459f98842327324d0df057">More...</a><br /></td></tr>
<tr class="separator:gaa8d0322515459f98842327324d0df057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81beffa94520d3e7a7d3ee04b3fd1f0b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga81beffa94520d3e7a7d3ee04b3fd1f0b">EtatOpenGL::obtenirChaineGlMapStencil</a> () const</td></tr>
<tr class="memdesc:ga81beffa94520d3e7a7d3ee04b3fd1f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAP_STENCIL.  <a href="#ga81beffa94520d3e7a7d3ee04b3fd1f0b">More...</a><br /></td></tr>
<tr class="separator:ga81beffa94520d3e7a7d3ee04b3fd1f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23caf97a7f7733b6a2b1959fb63c7c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa23caf97a7f7733b6a2b1959fb63c7c5">EtatOpenGL::obtenirChaineGlMatrixMode</a> () const</td></tr>
<tr class="memdesc:gaa23caf97a7f7733b6a2b1959fb63c7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MATRIX_MODE.  <a href="#gaa23caf97a7f7733b6a2b1959fb63c7c5">More...</a><br /></td></tr>
<tr class="separator:gaa23caf97a7f7733b6a2b1959fb63c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97547178b781217d7e84ab1efc8b03af"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga97547178b781217d7e84ab1efc8b03af">EtatOpenGL::obtenirChaineGlMaxClientAttribStackDepth</a> () const</td></tr>
<tr class="memdesc:ga97547178b781217d7e84ab1efc8b03af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH.  <a href="#ga97547178b781217d7e84ab1efc8b03af">More...</a><br /></td></tr>
<tr class="separator:ga97547178b781217d7e84ab1efc8b03af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050cc800f743296726f4bd93a756a6da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga050cc800f743296726f4bd93a756a6da">EtatOpenGL::obtenirChaineGlMaxAttribStackDepth</a> () const</td></tr>
<tr class="memdesc:ga050cc800f743296726f4bd93a756a6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_ATTRIB_STACK_DEPTH.  <a href="#ga050cc800f743296726f4bd93a756a6da">More...</a><br /></td></tr>
<tr class="separator:ga050cc800f743296726f4bd93a756a6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c9f2409548e8eb7777751869827fe1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac6c9f2409548e8eb7777751869827fe1">EtatOpenGL::obtenirChaineGlMaxClipPlanes</a> () const</td></tr>
<tr class="memdesc:gac6c9f2409548e8eb7777751869827fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_CLIP_PLANES.  <a href="#gac6c9f2409548e8eb7777751869827fe1">More...</a><br /></td></tr>
<tr class="separator:gac6c9f2409548e8eb7777751869827fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eeb23cefd74c0ebe845d124ffca5ddb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4eeb23cefd74c0ebe845d124ffca5ddb">EtatOpenGL::obtenirChaineGlMaxEvalOrder</a> () const</td></tr>
<tr class="memdesc:ga4eeb23cefd74c0ebe845d124ffca5ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_EVAL_ORDER.  <a href="#ga4eeb23cefd74c0ebe845d124ffca5ddb">More...</a><br /></td></tr>
<tr class="separator:ga4eeb23cefd74c0ebe845d124ffca5ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3973a9be1964aefbdfc832bf5e81dfe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa3973a9be1964aefbdfc832bf5e81dfe">EtatOpenGL::obtenirChaineGlMaxListNesting</a> () const</td></tr>
<tr class="memdesc:gaa3973a9be1964aefbdfc832bf5e81dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_LIST_NESTING.  <a href="#gaa3973a9be1964aefbdfc832bf5e81dfe">More...</a><br /></td></tr>
<tr class="separator:gaa3973a9be1964aefbdfc832bf5e81dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1220cb4537ba020af350dad3f4d338"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8f1220cb4537ba020af350dad3f4d338">EtatOpenGL::obtenirChaineGlMaxModelviewStackDepth</a> () const</td></tr>
<tr class="memdesc:ga8f1220cb4537ba020af350dad3f4d338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH.  <a href="#ga8f1220cb4537ba020af350dad3f4d338">More...</a><br /></td></tr>
<tr class="separator:ga8f1220cb4537ba020af350dad3f4d338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf757dc312caa43735a22d8d05b30d8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gacbf757dc312caa43735a22d8d05b30d8">EtatOpenGL::obtenirChaineGlMaxNameStackDepth</a> () const</td></tr>
<tr class="memdesc:gacbf757dc312caa43735a22d8d05b30d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_NAME_STACK_DEPTH.  <a href="#gacbf757dc312caa43735a22d8d05b30d8">More...</a><br /></td></tr>
<tr class="separator:gacbf757dc312caa43735a22d8d05b30d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace88fdb9dc01b7e5338842cff2ed3654"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gace88fdb9dc01b7e5338842cff2ed3654">EtatOpenGL::obtenirChaineGlMaxPixelMapTable</a> () const</td></tr>
<tr class="memdesc:gace88fdb9dc01b7e5338842cff2ed3654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_PIXEL_MAP_TABLE.  <a href="#gace88fdb9dc01b7e5338842cff2ed3654">More...</a><br /></td></tr>
<tr class="separator:gace88fdb9dc01b7e5338842cff2ed3654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7ce59e34f6586dc7a36fe549a9b012"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9a7ce59e34f6586dc7a36fe549a9b012">EtatOpenGL::obtenirChaineGlMaxProjectionStackDepth</a> () const</td></tr>
<tr class="memdesc:ga9a7ce59e34f6586dc7a36fe549a9b012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_PROJECTION_STACK_DEPTH.  <a href="#ga9a7ce59e34f6586dc7a36fe549a9b012">More...</a><br /></td></tr>
<tr class="separator:ga9a7ce59e34f6586dc7a36fe549a9b012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga508ab9a35dcf52e881d71fe4d14118f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga508ab9a35dcf52e881d71fe4d14118f9">EtatOpenGL::obtenirChaineGlMaxTextureSize</a> () const</td></tr>
<tr class="memdesc:ga508ab9a35dcf52e881d71fe4d14118f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_TEXTURE_SIZE.  <a href="#ga508ab9a35dcf52e881d71fe4d14118f9">More...</a><br /></td></tr>
<tr class="separator:ga508ab9a35dcf52e881d71fe4d14118f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c9ebbbdfbb76ddcc6a93b166e9cddb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga04c9ebbbdfbb76ddcc6a93b166e9cddb">EtatOpenGL::obtenirChaineGlMaxTextureStackDepth</a> () const</td></tr>
<tr class="memdesc:ga04c9ebbbdfbb76ddcc6a93b166e9cddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_TEXTURE_STACK_DEPTH.  <a href="#ga04c9ebbbdfbb76ddcc6a93b166e9cddb">More...</a><br /></td></tr>
<tr class="separator:ga04c9ebbbdfbb76ddcc6a93b166e9cddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb56f576ca5a4ce0cf7be52bc31f3573"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaeb56f576ca5a4ce0cf7be52bc31f3573">EtatOpenGL::obtenirChaineGlMaxViewportDims</a> () const</td></tr>
<tr class="memdesc:gaeb56f576ca5a4ce0cf7be52bc31f3573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MAX_VIEWPORT_DIMS.  <a href="#gaeb56f576ca5a4ce0cf7be52bc31f3573">More...</a><br /></td></tr>
<tr class="separator:gaeb56f576ca5a4ce0cf7be52bc31f3573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1480b4822a921b229b58e861492f063"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf1480b4822a921b229b58e861492f063">EtatOpenGL::obtenirChaineGlModelviewMatrix</a> () const</td></tr>
<tr class="memdesc:gaf1480b4822a921b229b58e861492f063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MODELVIEW_MATRIX.  <a href="#gaf1480b4822a921b229b58e861492f063">More...</a><br /></td></tr>
<tr class="separator:gaf1480b4822a921b229b58e861492f063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8040b27cf3e56f9a83eef63a194bbb08"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8040b27cf3e56f9a83eef63a194bbb08">EtatOpenGL::obtenirChaineGlModelviewStackDepth</a> () const</td></tr>
<tr class="memdesc:ga8040b27cf3e56f9a83eef63a194bbb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_MODELVIEW_STACK_DEPTH.  <a href="#ga8040b27cf3e56f9a83eef63a194bbb08">More...</a><br /></td></tr>
<tr class="separator:ga8040b27cf3e56f9a83eef63a194bbb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf203b021376db7b8df969ede06af5d40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf203b021376db7b8df969ede06af5d40">EtatOpenGL::obtenirChaineGlNameStackDepth</a> () const</td></tr>
<tr class="memdesc:gaf203b021376db7b8df969ede06af5d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_NAME_STACK_DEPTH.  <a href="#gaf203b021376db7b8df969ede06af5d40">More...</a><br /></td></tr>
<tr class="separator:gaf203b021376db7b8df969ede06af5d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce97d6b7493447f3a7758e991f44058"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4ce97d6b7493447f3a7758e991f44058">EtatOpenGL::obtenirChaineGlNormalArray</a> () const</td></tr>
<tr class="memdesc:ga4ce97d6b7493447f3a7758e991f44058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY.  <a href="#ga4ce97d6b7493447f3a7758e991f44058">More...</a><br /></td></tr>
<tr class="separator:ga4ce97d6b7493447f3a7758e991f44058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3073f0f33864989bf26ec4773633713"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa3073f0f33864989bf26ec4773633713">EtatOpenGL::obtenirChaineGlNormalArrayStride</a> () const</td></tr>
<tr class="memdesc:gaa3073f0f33864989bf26ec4773633713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY_STRIDE.  <a href="#gaa3073f0f33864989bf26ec4773633713">More...</a><br /></td></tr>
<tr class="separator:gaa3073f0f33864989bf26ec4773633713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7635092692d14683acc8fd7c9a1a8181"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7635092692d14683acc8fd7c9a1a8181">EtatOpenGL::obtenirChaineGlNormalArrayType</a> () const</td></tr>
<tr class="memdesc:ga7635092692d14683acc8fd7c9a1a8181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY_TYPE.  <a href="#ga7635092692d14683acc8fd7c9a1a8181">More...</a><br /></td></tr>
<tr class="separator:ga7635092692d14683acc8fd7c9a1a8181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b456e82a37616498b7a1c894b8b308c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8b456e82a37616498b7a1c894b8b308c">EtatOpenGL::obtenirChaineGlNormalize</a> () const</td></tr>
<tr class="memdesc:ga8b456e82a37616498b7a1c894b8b308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_NORMALIZE.  <a href="#ga8b456e82a37616498b7a1c894b8b308c">More...</a><br /></td></tr>
<tr class="separator:ga8b456e82a37616498b7a1c894b8b308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa85adce47c7da66ee96dfa8d462a03a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaaa85adce47c7da66ee96dfa8d462a03a">EtatOpenGL::obtenirChaineGlPackAlignment</a> () const</td></tr>
<tr class="memdesc:gaaa85adce47c7da66ee96dfa8d462a03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PACK_ALIGNMENT.  <a href="#gaaa85adce47c7da66ee96dfa8d462a03a">More...</a><br /></td></tr>
<tr class="separator:gaaa85adce47c7da66ee96dfa8d462a03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f6dcd0faaced3739699bbcd76b1c71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga78f6dcd0faaced3739699bbcd76b1c71">EtatOpenGL::obtenirChaineGlPackLsbFirst</a> () const</td></tr>
<tr class="memdesc:ga78f6dcd0faaced3739699bbcd76b1c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PACK_LSB_FIRST.  <a href="#ga78f6dcd0faaced3739699bbcd76b1c71">More...</a><br /></td></tr>
<tr class="separator:ga78f6dcd0faaced3739699bbcd76b1c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ad9e22422fc5697d2a70b2b2684d63"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga55ad9e22422fc5697d2a70b2b2684d63">EtatOpenGL::obtenirChaineGlPackRowLength</a> () const</td></tr>
<tr class="memdesc:ga55ad9e22422fc5697d2a70b2b2684d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PACK_ROW_LENGTH.  <a href="#ga55ad9e22422fc5697d2a70b2b2684d63">More...</a><br /></td></tr>
<tr class="separator:ga55ad9e22422fc5697d2a70b2b2684d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a242f17034ea2356363a1e0a4758c90"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8a242f17034ea2356363a1e0a4758c90">EtatOpenGL::obtenirChaineGlPackSkipPixels</a> () const</td></tr>
<tr class="memdesc:ga8a242f17034ea2356363a1e0a4758c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PACK_SKIP_PIXELS.  <a href="#ga8a242f17034ea2356363a1e0a4758c90">More...</a><br /></td></tr>
<tr class="separator:ga8a242f17034ea2356363a1e0a4758c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44b7fc6e446520ab2768d997f05a766"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab44b7fc6e446520ab2768d997f05a766">EtatOpenGL::obtenirChaineGlPackSkipRows</a> () const</td></tr>
<tr class="memdesc:gab44b7fc6e446520ab2768d997f05a766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PACK_SKIP_ROWS.  <a href="#gab44b7fc6e446520ab2768d997f05a766">More...</a><br /></td></tr>
<tr class="separator:gab44b7fc6e446520ab2768d997f05a766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab7a4474cc998f813c9e628fcd3cc2a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9ab7a4474cc998f813c9e628fcd3cc2a">EtatOpenGL::obtenirChaineGlPackSwapBytes</a> () const</td></tr>
<tr class="memdesc:ga9ab7a4474cc998f813c9e628fcd3cc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PACK_SWAP_BYTES.  <a href="#ga9ab7a4474cc998f813c9e628fcd3cc2a">More...</a><br /></td></tr>
<tr class="separator:ga9ab7a4474cc998f813c9e628fcd3cc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12b3f79146d08ef8b3bafa9e4b93886"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa12b3f79146d08ef8b3bafa9e4b93886">EtatOpenGL::obtenirChaineGlPerspectiveCorrectionHint</a> () const</td></tr>
<tr class="memdesc:gaa12b3f79146d08ef8b3bafa9e4b93886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PERSPECTIVE_CORRECTION_HINT.  <a href="#gaa12b3f79146d08ef8b3bafa9e4b93886">More...</a><br /></td></tr>
<tr class="separator:gaa12b3f79146d08ef8b3bafa9e4b93886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b02a331655953bb9fd872ba2fee3562"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9b02a331655953bb9fd872ba2fee3562">EtatOpenGL::obtenirChaineGlPixelMapAToASize</a> () const</td></tr>
<tr class="memdesc:ga9b02a331655953bb9fd872ba2fee3562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE.  <a href="#ga9b02a331655953bb9fd872ba2fee3562">More...</a><br /></td></tr>
<tr class="separator:ga9b02a331655953bb9fd872ba2fee3562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc081b3862bbe1cb5a5038d9bab83ed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5fc081b3862bbe1cb5a5038d9bab83ed">EtatOpenGL::obtenirChaineGlPixelMapBToBSize</a> () const</td></tr>
<tr class="memdesc:ga5fc081b3862bbe1cb5a5038d9bab83ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE.  <a href="#ga5fc081b3862bbe1cb5a5038d9bab83ed">More...</a><br /></td></tr>
<tr class="separator:ga5fc081b3862bbe1cb5a5038d9bab83ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc643dc88cf9ef2805ba8d36ae78204"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4bc643dc88cf9ef2805ba8d36ae78204">EtatOpenGL::obtenirChaineGlPixelMapGToGSize</a> () const</td></tr>
<tr class="memdesc:ga4bc643dc88cf9ef2805ba8d36ae78204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE.  <a href="#ga4bc643dc88cf9ef2805ba8d36ae78204">More...</a><br /></td></tr>
<tr class="separator:ga4bc643dc88cf9ef2805ba8d36ae78204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0746cb24bca308640dc74b50936572d1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0746cb24bca308640dc74b50936572d1">EtatOpenGL::obtenirChaineGlPixelMapIToASize</a> () const</td></tr>
<tr class="memdesc:ga0746cb24bca308640dc74b50936572d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE.  <a href="#ga0746cb24bca308640dc74b50936572d1">More...</a><br /></td></tr>
<tr class="separator:ga0746cb24bca308640dc74b50936572d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c2c0672eee401a0a4b68f498135018c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9c2c0672eee401a0a4b68f498135018c">EtatOpenGL::obtenirChaineGlPixelMapIToBSize</a> () const</td></tr>
<tr class="memdesc:ga9c2c0672eee401a0a4b68f498135018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE.  <a href="#ga9c2c0672eee401a0a4b68f498135018c">More...</a><br /></td></tr>
<tr class="separator:ga9c2c0672eee401a0a4b68f498135018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04b44bd5fb37682122f9706cae79ce7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa04b44bd5fb37682122f9706cae79ce7">EtatOpenGL::obtenirChaineGlPixelMapIToGSize</a> () const</td></tr>
<tr class="memdesc:gaa04b44bd5fb37682122f9706cae79ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE.  <a href="#gaa04b44bd5fb37682122f9706cae79ce7">More...</a><br /></td></tr>
<tr class="separator:gaa04b44bd5fb37682122f9706cae79ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5383c7a5bae41cf7d3303ceb9cf582bf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5383c7a5bae41cf7d3303ceb9cf582bf">EtatOpenGL::obtenirChaineGlPixelMapIToISize</a> () const</td></tr>
<tr class="memdesc:ga5383c7a5bae41cf7d3303ceb9cf582bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE.  <a href="#ga5383c7a5bae41cf7d3303ceb9cf582bf">More...</a><br /></td></tr>
<tr class="separator:ga5383c7a5bae41cf7d3303ceb9cf582bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d54f0be62b1259f9497c5840ec1464d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga9d54f0be62b1259f9497c5840ec1464d">EtatOpenGL::obtenirChaineGlPixelMapIToRSize</a> () const</td></tr>
<tr class="memdesc:ga9d54f0be62b1259f9497c5840ec1464d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE.  <a href="#ga9d54f0be62b1259f9497c5840ec1464d">More...</a><br /></td></tr>
<tr class="separator:ga9d54f0be62b1259f9497c5840ec1464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf773e5f5e598b47fa22088144ca761d1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf773e5f5e598b47fa22088144ca761d1">EtatOpenGL::obtenirChaineGlPixelMapRToRSize</a> () const</td></tr>
<tr class="memdesc:gaf773e5f5e598b47fa22088144ca761d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE.  <a href="#gaf773e5f5e598b47fa22088144ca761d1">More...</a><br /></td></tr>
<tr class="separator:gaf773e5f5e598b47fa22088144ca761d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5706b973e085773d950078b78a2b620"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaa5706b973e085773d950078b78a2b620">EtatOpenGL::obtenirChaineGlPixelMapSToSSize</a> () const</td></tr>
<tr class="memdesc:gaa5706b973e085773d950078b78a2b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE.  <a href="#gaa5706b973e085773d950078b78a2b620">More...</a><br /></td></tr>
<tr class="separator:gaa5706b973e085773d950078b78a2b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b174cc2333e6c33bfc51799c6b2c12"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad7b174cc2333e6c33bfc51799c6b2c12">EtatOpenGL::obtenirChaineGlPointSize</a> () const</td></tr>
<tr class="memdesc:gad7b174cc2333e6c33bfc51799c6b2c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POINT_SIZE.  <a href="#gad7b174cc2333e6c33bfc51799c6b2c12">More...</a><br /></td></tr>
<tr class="separator:gad7b174cc2333e6c33bfc51799c6b2c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88a08fbe834fcf661f5998c66db80f4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac88a08fbe834fcf661f5998c66db80f4">EtatOpenGL::obtenirChaineGlPointSizeGranularity</a> () const</td></tr>
<tr class="memdesc:gac88a08fbe834fcf661f5998c66db80f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POINT_SIZE_GRANULARITY.  <a href="#gac88a08fbe834fcf661f5998c66db80f4">More...</a><br /></td></tr>
<tr class="separator:gac88a08fbe834fcf661f5998c66db80f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87ef6371391b2e7ba77107bfe492dbb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf87ef6371391b2e7ba77107bfe492dbb">EtatOpenGL::obtenirChaineGlPointSizeRange</a> () const</td></tr>
<tr class="memdesc:gaf87ef6371391b2e7ba77107bfe492dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POINT_SIZE_RANGE.  <a href="#gaf87ef6371391b2e7ba77107bfe492dbb">More...</a><br /></td></tr>
<tr class="separator:gaf87ef6371391b2e7ba77107bfe492dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd0c8209c85b0a1cf4b5fa9413fcd1a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaffd0c8209c85b0a1cf4b5fa9413fcd1a">EtatOpenGL::obtenirChaineGlPointSmooth</a> () const</td></tr>
<tr class="memdesc:gaffd0c8209c85b0a1cf4b5fa9413fcd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POINT_SMOOTH.  <a href="#gaffd0c8209c85b0a1cf4b5fa9413fcd1a">More...</a><br /></td></tr>
<tr class="separator:gaffd0c8209c85b0a1cf4b5fa9413fcd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab166c857613b362db6dc0e2d420febe5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab166c857613b362db6dc0e2d420febe5">EtatOpenGL::obtenirChaineGlPointSmoothHint</a> () const</td></tr>
<tr class="memdesc:gab166c857613b362db6dc0e2d420febe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POINT_SMOOTH_HINT.  <a href="#gab166c857613b362db6dc0e2d420febe5">More...</a><br /></td></tr>
<tr class="separator:gab166c857613b362db6dc0e2d420febe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05467477ba232dd5fcd36e17b8d40385"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga05467477ba232dd5fcd36e17b8d40385">EtatOpenGL::obtenirChaineGlPolygonMode</a> () const</td></tr>
<tr class="memdesc:ga05467477ba232dd5fcd36e17b8d40385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_MODE.  <a href="#ga05467477ba232dd5fcd36e17b8d40385">More...</a><br /></td></tr>
<tr class="separator:ga05467477ba232dd5fcd36e17b8d40385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e23b892dccca468bc208aa64505dbd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga59e23b892dccca468bc208aa64505dbd">EtatOpenGL::obtenirChaineGlPolygonOffsetFactor</a> () const</td></tr>
<tr class="memdesc:ga59e23b892dccca468bc208aa64505dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_FACTOR.  <a href="#ga59e23b892dccca468bc208aa64505dbd">More...</a><br /></td></tr>
<tr class="separator:ga59e23b892dccca468bc208aa64505dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfa2ace0eaa2cd2f5e4b773e16b27fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafdfa2ace0eaa2cd2f5e4b773e16b27fe">EtatOpenGL::obtenirChaineGlPolygonOffsetUnits</a> () const</td></tr>
<tr class="memdesc:gafdfa2ace0eaa2cd2f5e4b773e16b27fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_UNITS.  <a href="#gafdfa2ace0eaa2cd2f5e4b773e16b27fe">More...</a><br /></td></tr>
<tr class="separator:gafdfa2ace0eaa2cd2f5e4b773e16b27fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c75b08296744c8c67c75e3061377b8a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1c75b08296744c8c67c75e3061377b8a">EtatOpenGL::obtenirChaineGlPolygonOffsetFill</a> () const</td></tr>
<tr class="memdesc:ga1c75b08296744c8c67c75e3061377b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_FILL.  <a href="#ga1c75b08296744c8c67c75e3061377b8a">More...</a><br /></td></tr>
<tr class="separator:ga1c75b08296744c8c67c75e3061377b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab655913662359133d622e393aa3b9ba7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab655913662359133d622e393aa3b9ba7">EtatOpenGL::obtenirChaineGlPolygonOffsetLine</a> () const</td></tr>
<tr class="memdesc:gab655913662359133d622e393aa3b9ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_LINE.  <a href="#gab655913662359133d622e393aa3b9ba7">More...</a><br /></td></tr>
<tr class="separator:gab655913662359133d622e393aa3b9ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55c86fd41a6399f87d2bbb9adf200325"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga55c86fd41a6399f87d2bbb9adf200325">EtatOpenGL::obtenirChaineGlPolygonOffsetPoint</a> () const</td></tr>
<tr class="memdesc:ga55c86fd41a6399f87d2bbb9adf200325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_POINT.  <a href="#ga55c86fd41a6399f87d2bbb9adf200325">More...</a><br /></td></tr>
<tr class="separator:ga55c86fd41a6399f87d2bbb9adf200325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2369a9f60619021a9df5aae539435bc3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2369a9f60619021a9df5aae539435bc3">EtatOpenGL::obtenirChaineGlPolygonSmooth</a> () const</td></tr>
<tr class="memdesc:ga2369a9f60619021a9df5aae539435bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_SMOOTH.  <a href="#ga2369a9f60619021a9df5aae539435bc3">More...</a><br /></td></tr>
<tr class="separator:ga2369a9f60619021a9df5aae539435bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87309eb95b99cdb1711f1c1fa2394f0d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga87309eb95b99cdb1711f1c1fa2394f0d">EtatOpenGL::obtenirChaineGlPolygonSmoothHint</a> () const</td></tr>
<tr class="memdesc:ga87309eb95b99cdb1711f1c1fa2394f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_SMOOTH_HINT.  <a href="#ga87309eb95b99cdb1711f1c1fa2394f0d">More...</a><br /></td></tr>
<tr class="separator:ga87309eb95b99cdb1711f1c1fa2394f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e2e465a5c151e2fff64f3e7f12fef3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga14e2e465a5c151e2fff64f3e7f12fef3">EtatOpenGL::obtenirChaineGlPolygonStipple</a> () const</td></tr>
<tr class="memdesc:ga14e2e465a5c151e2fff64f3e7f12fef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_POLYGON_STIPPLE.  <a href="#ga14e2e465a5c151e2fff64f3e7f12fef3">More...</a><br /></td></tr>
<tr class="separator:ga14e2e465a5c151e2fff64f3e7f12fef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c176113dd3186a52270079433680b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga40c176113dd3186a52270079433680b9">EtatOpenGL::obtenirChaineGlProjectionMatrix</a> () const</td></tr>
<tr class="memdesc:ga40c176113dd3186a52270079433680b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PROJECTION_MATRIX.  <a href="#ga40c176113dd3186a52270079433680b9">More...</a><br /></td></tr>
<tr class="separator:ga40c176113dd3186a52270079433680b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8f030d737a1f7fb5a34ad866cfebb4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga4a8f030d737a1f7fb5a34ad866cfebb4">EtatOpenGL::obtenirChaineGlProjectionStackDepth</a> () const</td></tr>
<tr class="memdesc:ga4a8f030d737a1f7fb5a34ad866cfebb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_PROJECTION_STACK_DEPTH.  <a href="#ga4a8f030d737a1f7fb5a34ad866cfebb4">More...</a><br /></td></tr>
<tr class="separator:ga4a8f030d737a1f7fb5a34ad866cfebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2de1c0bd2290f8a19abcf2437ebd150"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf2de1c0bd2290f8a19abcf2437ebd150">EtatOpenGL::obtenirChaineGlReadBuffer</a> () const</td></tr>
<tr class="memdesc:gaf2de1c0bd2290f8a19abcf2437ebd150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_READ_BUFFER.  <a href="#gaf2de1c0bd2290f8a19abcf2437ebd150">More...</a><br /></td></tr>
<tr class="separator:gaf2de1c0bd2290f8a19abcf2437ebd150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06eff0093b19074897fd133ed367d9ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga06eff0093b19074897fd133ed367d9ff">EtatOpenGL::obtenirChaineGlRedBias</a> () const</td></tr>
<tr class="memdesc:ga06eff0093b19074897fd133ed367d9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_RED_BIAS.  <a href="#ga06eff0093b19074897fd133ed367d9ff">More...</a><br /></td></tr>
<tr class="separator:ga06eff0093b19074897fd133ed367d9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56a19dc9a4529bef6aa2c554feda890"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gad56a19dc9a4529bef6aa2c554feda890">EtatOpenGL::obtenirChaineGlRedBits</a> () const</td></tr>
<tr class="memdesc:gad56a19dc9a4529bef6aa2c554feda890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_RED_BITS.  <a href="#gad56a19dc9a4529bef6aa2c554feda890">More...</a><br /></td></tr>
<tr class="separator:gad56a19dc9a4529bef6aa2c554feda890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52067c6e1d8fa44b48bf4dd810701a15"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga52067c6e1d8fa44b48bf4dd810701a15">EtatOpenGL::obtenirChaineGlRedScale</a> () const</td></tr>
<tr class="memdesc:ga52067c6e1d8fa44b48bf4dd810701a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_RED_SCALE.  <a href="#ga52067c6e1d8fa44b48bf4dd810701a15">More...</a><br /></td></tr>
<tr class="separator:ga52067c6e1d8fa44b48bf4dd810701a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2eb228c03ceca3464a9e83d2023f492"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf2eb228c03ceca3464a9e83d2023f492">EtatOpenGL::obtenirChaineGlRenderMode</a> () const</td></tr>
<tr class="memdesc:gaf2eb228c03ceca3464a9e83d2023f492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_RENDER_MODE.  <a href="#gaf2eb228c03ceca3464a9e83d2023f492">More...</a><br /></td></tr>
<tr class="separator:gaf2eb228c03ceca3464a9e83d2023f492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c76be29c24d6171080188bd786307c8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga8c76be29c24d6171080188bd786307c8">EtatOpenGL::obtenirChaineGlRgbaMode</a> () const</td></tr>
<tr class="memdesc:ga8c76be29c24d6171080188bd786307c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_RGBA_MODE.  <a href="#ga8c76be29c24d6171080188bd786307c8">More...</a><br /></td></tr>
<tr class="separator:ga8c76be29c24d6171080188bd786307c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5397b24eddfea01b757f86500e01ca91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5397b24eddfea01b757f86500e01ca91">EtatOpenGL::obtenirChaineGlScissorBox</a> () const</td></tr>
<tr class="memdesc:ga5397b24eddfea01b757f86500e01ca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_SCISSOR_BOX.  <a href="#ga5397b24eddfea01b757f86500e01ca91">More...</a><br /></td></tr>
<tr class="separator:ga5397b24eddfea01b757f86500e01ca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f2d3e07f847eebf09f5a1887cebf31"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga94f2d3e07f847eebf09f5a1887cebf31">EtatOpenGL::obtenirChaineGlScissorTest</a> () const</td></tr>
<tr class="memdesc:ga94f2d3e07f847eebf09f5a1887cebf31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_SCISSOR_TEST.  <a href="#ga94f2d3e07f847eebf09f5a1887cebf31">More...</a><br /></td></tr>
<tr class="separator:ga94f2d3e07f847eebf09f5a1887cebf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92126b4a8c29117620315ed25f1ecc63"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga92126b4a8c29117620315ed25f1ecc63">EtatOpenGL::obtenirChaineGlSelectionBufferSize</a> () const</td></tr>
<tr class="memdesc:ga92126b4a8c29117620315ed25f1ecc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_SELECTION_BUFFER_SIZE.  <a href="#ga92126b4a8c29117620315ed25f1ecc63">More...</a><br /></td></tr>
<tr class="separator:ga92126b4a8c29117620315ed25f1ecc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a76a5d09a39eb621b569461e91e858"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab3a76a5d09a39eb621b569461e91e858">EtatOpenGL::obtenirChaineGlShadeModel</a> () const</td></tr>
<tr class="memdesc:gab3a76a5d09a39eb621b569461e91e858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_SHADE_MODEL.  <a href="#gab3a76a5d09a39eb621b569461e91e858">More...</a><br /></td></tr>
<tr class="separator:gab3a76a5d09a39eb621b569461e91e858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1345260afe74206391e4135d00fcb63"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf1345260afe74206391e4135d00fcb63">EtatOpenGL::obtenirChaineGlStencilBits</a> () const</td></tr>
<tr class="memdesc:gaf1345260afe74206391e4135d00fcb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_BITS.  <a href="#gaf1345260afe74206391e4135d00fcb63">More...</a><br /></td></tr>
<tr class="separator:gaf1345260afe74206391e4135d00fcb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3af85b29e73001331e92b27d192fb7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaab3af85b29e73001331e92b27d192fb7">EtatOpenGL::obtenirChaineGlStencilClearValue</a> () const</td></tr>
<tr class="memdesc:gaab3af85b29e73001331e92b27d192fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_CLEAR_VALUE.  <a href="#gaab3af85b29e73001331e92b27d192fb7">More...</a><br /></td></tr>
<tr class="separator:gaab3af85b29e73001331e92b27d192fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga923a65eef9235ac8b0a443e05c9f5c5a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga923a65eef9235ac8b0a443e05c9f5c5a">EtatOpenGL::obtenirChaineGlStencilFail</a> () const</td></tr>
<tr class="memdesc:ga923a65eef9235ac8b0a443e05c9f5c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_FAIL.  <a href="#ga923a65eef9235ac8b0a443e05c9f5c5a">More...</a><br /></td></tr>
<tr class="separator:ga923a65eef9235ac8b0a443e05c9f5c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52b8984d0924fa3d0d05b63b67b46e8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gac52b8984d0924fa3d0d05b63b67b46e8">EtatOpenGL::obtenirChaineGlStencilFunc</a> () const</td></tr>
<tr class="memdesc:gac52b8984d0924fa3d0d05b63b67b46e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_FUNC.  <a href="#gac52b8984d0924fa3d0d05b63b67b46e8">More...</a><br /></td></tr>
<tr class="separator:gac52b8984d0924fa3d0d05b63b67b46e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e43430a722833aa85b377b40cbfaf2c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga5e43430a722833aa85b377b40cbfaf2c">EtatOpenGL::obtenirChaineGlStencilPassDepthFail</a> () const</td></tr>
<tr class="memdesc:ga5e43430a722833aa85b377b40cbfaf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_FAIL.  <a href="#ga5e43430a722833aa85b377b40cbfaf2c">More...</a><br /></td></tr>
<tr class="separator:ga5e43430a722833aa85b377b40cbfaf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade8c552e1ab102d594f33dc42e24b15c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gade8c552e1ab102d594f33dc42e24b15c">EtatOpenGL::obtenirChaineGlStencilPassDepthPass</a> () const</td></tr>
<tr class="memdesc:gade8c552e1ab102d594f33dc42e24b15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_PASS.  <a href="#gade8c552e1ab102d594f33dc42e24b15c">More...</a><br /></td></tr>
<tr class="separator:gade8c552e1ab102d594f33dc42e24b15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277fcf055256635d9b1805280ec3cbc3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga277fcf055256635d9b1805280ec3cbc3">EtatOpenGL::obtenirChaineGlStencilRef</a> () const</td></tr>
<tr class="memdesc:ga277fcf055256635d9b1805280ec3cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_REF.  <a href="#ga277fcf055256635d9b1805280ec3cbc3">More...</a><br /></td></tr>
<tr class="separator:ga277fcf055256635d9b1805280ec3cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed31aaa16c09247896df7b92d9552655"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaed31aaa16c09247896df7b92d9552655">EtatOpenGL::obtenirChaineGlStencilTest</a> () const</td></tr>
<tr class="memdesc:gaed31aaa16c09247896df7b92d9552655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_TEST.  <a href="#gaed31aaa16c09247896df7b92d9552655">More...</a><br /></td></tr>
<tr class="separator:gaed31aaa16c09247896df7b92d9552655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cbf8f4a60d17db09c4f68535c7f70fc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6cbf8f4a60d17db09c4f68535c7f70fc">EtatOpenGL::obtenirChaineGlStencilValueMask</a> () const</td></tr>
<tr class="memdesc:ga6cbf8f4a60d17db09c4f68535c7f70fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_VALUE_MASK.  <a href="#ga6cbf8f4a60d17db09c4f68535c7f70fc">More...</a><br /></td></tr>
<tr class="separator:ga6cbf8f4a60d17db09c4f68535c7f70fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd84c41a78ec45d41bc97b95a15f9fc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1dd84c41a78ec45d41bc97b95a15f9fc">EtatOpenGL::obtenirChaineGlStencilWritemask</a> () const</td></tr>
<tr class="memdesc:ga1dd84c41a78ec45d41bc97b95a15f9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STENCIL_WRITEMASK.  <a href="#ga1dd84c41a78ec45d41bc97b95a15f9fc">More...</a><br /></td></tr>
<tr class="separator:ga1dd84c41a78ec45d41bc97b95a15f9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77baae4c5b5df2f3e76b062b2862f920"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga77baae4c5b5df2f3e76b062b2862f920">EtatOpenGL::obtenirChaineGlStereo</a> () const</td></tr>
<tr class="memdesc:ga77baae4c5b5df2f3e76b062b2862f920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_STEREO.  <a href="#ga77baae4c5b5df2f3e76b062b2862f920">More...</a><br /></td></tr>
<tr class="separator:ga77baae4c5b5df2f3e76b062b2862f920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a003ccc8f459a98d31b336082d12960"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0a003ccc8f459a98d31b336082d12960">EtatOpenGL::obtenirChaineGlSubpixelBits</a> () const</td></tr>
<tr class="memdesc:ga0a003ccc8f459a98d31b336082d12960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_SUBPIXEL_BITS.  <a href="#ga0a003ccc8f459a98d31b336082d12960">More...</a><br /></td></tr>
<tr class="separator:ga0a003ccc8f459a98d31b336082d12960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ecac3a1ee37165021792ff4ef273b89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2ecac3a1ee37165021792ff4ef273b89">EtatOpenGL::obtenirChaineGlTexture1D</a> () const</td></tr>
<tr class="memdesc:ga2ecac3a1ee37165021792ff4ef273b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_1D.  <a href="#ga2ecac3a1ee37165021792ff4ef273b89">More...</a><br /></td></tr>
<tr class="separator:ga2ecac3a1ee37165021792ff4ef273b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea59e236a466ac41b9130f12f5c5a6e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gacea59e236a466ac41b9130f12f5c5a6e">EtatOpenGL::obtenirChaineGlTextureBinding1D</a> () const</td></tr>
<tr class="memdesc:gacea59e236a466ac41b9130f12f5c5a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_BINDING_1D.  <a href="#gacea59e236a466ac41b9130f12f5c5a6e">More...</a><br /></td></tr>
<tr class="separator:gacea59e236a466ac41b9130f12f5c5a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156f1a8be92219db140f7c1daca8a2b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga156f1a8be92219db140f7c1daca8a2b5">EtatOpenGL::obtenirChaineGlTexture2D</a> () const</td></tr>
<tr class="memdesc:ga156f1a8be92219db140f7c1daca8a2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_2D.  <a href="#ga156f1a8be92219db140f7c1daca8a2b5">More...</a><br /></td></tr>
<tr class="separator:ga156f1a8be92219db140f7c1daca8a2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ae24572f99408cb84c1571e6cae72e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga87ae24572f99408cb84c1571e6cae72e">EtatOpenGL::obtenirChaineGlTextureBinding2D</a> () const</td></tr>
<tr class="memdesc:ga87ae24572f99408cb84c1571e6cae72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_BINDING_2D.  <a href="#ga87ae24572f99408cb84c1571e6cae72e">More...</a><br /></td></tr>
<tr class="separator:ga87ae24572f99408cb84c1571e6cae72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c00f3420ee159b23e0e102b7948d4a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga07c00f3420ee159b23e0e102b7948d4a">EtatOpenGL::obtenirChaineGlTextureCoordArray</a> () const</td></tr>
<tr class="memdesc:ga07c00f3420ee159b23e0e102b7948d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY.  <a href="#ga07c00f3420ee159b23e0e102b7948d4a">More...</a><br /></td></tr>
<tr class="separator:ga07c00f3420ee159b23e0e102b7948d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7468bc8b89c05868239f4f53ec84cf7a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga7468bc8b89c05868239f4f53ec84cf7a">EtatOpenGL::obtenirChaineGlTextureCoordArraySize</a> () const</td></tr>
<tr class="memdesc:ga7468bc8b89c05868239f4f53ec84cf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE.  <a href="#ga7468bc8b89c05868239f4f53ec84cf7a">More...</a><br /></td></tr>
<tr class="separator:ga7468bc8b89c05868239f4f53ec84cf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a9abaf5f85c142d16fb58c00a25b51"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga97a9abaf5f85c142d16fb58c00a25b51">EtatOpenGL::obtenirChaineGlTextureCoordArrayStride</a> () const</td></tr>
<tr class="memdesc:ga97a9abaf5f85c142d16fb58c00a25b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE.  <a href="#ga97a9abaf5f85c142d16fb58c00a25b51">More...</a><br /></td></tr>
<tr class="separator:ga97a9abaf5f85c142d16fb58c00a25b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d6fb5e06dce2c10c5066cb94f5f481e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6d6fb5e06dce2c10c5066cb94f5f481e">EtatOpenGL::obtenirChaineGlTextureCoordArrayType</a> () const</td></tr>
<tr class="memdesc:ga6d6fb5e06dce2c10c5066cb94f5f481e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE.  <a href="#ga6d6fb5e06dce2c10c5066cb94f5f481e">More...</a><br /></td></tr>
<tr class="separator:ga6d6fb5e06dce2c10c5066cb94f5f481e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a34df2187456533ca64fb547c3c4290"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga0a34df2187456533ca64fb547c3c4290">EtatOpenGL::obtenirChaineGlTextureGenQ</a> () const</td></tr>
<tr class="memdesc:ga0a34df2187456533ca64fb547c3c4290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_Q.  <a href="#ga0a34df2187456533ca64fb547c3c4290">More...</a><br /></td></tr>
<tr class="separator:ga0a34df2187456533ca64fb547c3c4290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42023690076a0152885688263ca95a09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga42023690076a0152885688263ca95a09">EtatOpenGL::obtenirChaineGlTextureGenR</a> () const</td></tr>
<tr class="memdesc:ga42023690076a0152885688263ca95a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_R.  <a href="#ga42023690076a0152885688263ca95a09">More...</a><br /></td></tr>
<tr class="separator:ga42023690076a0152885688263ca95a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72cdc9bcc2a13d27b00cde994d4b458"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gab72cdc9bcc2a13d27b00cde994d4b458">EtatOpenGL::obtenirChaineGlTextureGenS</a> () const</td></tr>
<tr class="memdesc:gab72cdc9bcc2a13d27b00cde994d4b458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_S.  <a href="#gab72cdc9bcc2a13d27b00cde994d4b458">More...</a><br /></td></tr>
<tr class="separator:gab72cdc9bcc2a13d27b00cde994d4b458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38aadd8bf15030bf34dc675c25e290b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga38aadd8bf15030bf34dc675c25e290b1">EtatOpenGL::obtenirChaineGlTextureGenT</a> () const</td></tr>
<tr class="memdesc:ga38aadd8bf15030bf34dc675c25e290b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_T.  <a href="#ga38aadd8bf15030bf34dc675c25e290b1">More...</a><br /></td></tr>
<tr class="separator:ga38aadd8bf15030bf34dc675c25e290b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf136718e2ddd7373a9ddb2e00a636668"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf136718e2ddd7373a9ddb2e00a636668">EtatOpenGL::obtenirChaineGlTextureMatrix</a> () const</td></tr>
<tr class="memdesc:gaf136718e2ddd7373a9ddb2e00a636668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_MATRIX.  <a href="#gaf136718e2ddd7373a9ddb2e00a636668">More...</a><br /></td></tr>
<tr class="separator:gaf136718e2ddd7373a9ddb2e00a636668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0088db61ba425e00e242226c23eba0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga3c0088db61ba425e00e242226c23eba0">EtatOpenGL::obtenirChaineGlTextureStackDepth</a> () const</td></tr>
<tr class="memdesc:ga3c0088db61ba425e00e242226c23eba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_TEXTURE_STACK_DEPTH.  <a href="#ga3c0088db61ba425e00e242226c23eba0">More...</a><br /></td></tr>
<tr class="separator:ga3c0088db61ba425e00e242226c23eba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa90f70671fa28856396c42bed13d3bb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafa90f70671fa28856396c42bed13d3bb">EtatOpenGL::obtenirChaineGlUnpackAlignment</a> () const</td></tr>
<tr class="memdesc:gafa90f70671fa28856396c42bed13d3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_UNPACK_ALIGNMENT.  <a href="#gafa90f70671fa28856396c42bed13d3bb">More...</a><br /></td></tr>
<tr class="separator:gafa90f70671fa28856396c42bed13d3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae116760ea6ac4fcbe0066a1754459255"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gae116760ea6ac4fcbe0066a1754459255">EtatOpenGL::obtenirChaineGlUnpackLsbFirst</a> () const</td></tr>
<tr class="memdesc:gae116760ea6ac4fcbe0066a1754459255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_UNPACK_LSB_FIRST.  <a href="#gae116760ea6ac4fcbe0066a1754459255">More...</a><br /></td></tr>
<tr class="separator:gae116760ea6ac4fcbe0066a1754459255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e1a047daef580289cc434ac07334cf4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2e1a047daef580289cc434ac07334cf4">EtatOpenGL::obtenirChaineGlUnpackRowLength</a> () const</td></tr>
<tr class="memdesc:ga2e1a047daef580289cc434ac07334cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_UNPACK_ROW_LENGTH.  <a href="#ga2e1a047daef580289cc434ac07334cf4">More...</a><br /></td></tr>
<tr class="separator:ga2e1a047daef580289cc434ac07334cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c1baab4bf7aec317569d7f01792de4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaf3c1baab4bf7aec317569d7f01792de4">EtatOpenGL::obtenirChaineGlUnpackSkipPixels</a> () const</td></tr>
<tr class="memdesc:gaf3c1baab4bf7aec317569d7f01792de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_UNPACK_SKIP_PIXELS.  <a href="#gaf3c1baab4bf7aec317569d7f01792de4">More...</a><br /></td></tr>
<tr class="separator:gaf3c1baab4bf7aec317569d7f01792de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3852f51ffcf4b7244315ffc7f1e5e7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga1a3852f51ffcf4b7244315ffc7f1e5e7">EtatOpenGL::obtenirChaineGlUnpackSkipRows</a> () const</td></tr>
<tr class="memdesc:ga1a3852f51ffcf4b7244315ffc7f1e5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_UNPACK_SKIP_ROWS.  <a href="#ga1a3852f51ffcf4b7244315ffc7f1e5e7">More...</a><br /></td></tr>
<tr class="separator:ga1a3852f51ffcf4b7244315ffc7f1e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d5f3633b0778ee675f5c6dcd8ce02c8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga6d5f3633b0778ee675f5c6dcd8ce02c8">EtatOpenGL::obtenirChaineGlUnpackSwapBytes</a> () const</td></tr>
<tr class="memdesc:ga6d5f3633b0778ee675f5c6dcd8ce02c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_UNPACK_SWAP_BYTES.  <a href="#ga6d5f3633b0778ee675f5c6dcd8ce02c8">More...</a><br /></td></tr>
<tr class="separator:ga6d5f3633b0778ee675f5c6dcd8ce02c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296737a05545afeefee6e3ff51fb9e9f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga296737a05545afeefee6e3ff51fb9e9f">EtatOpenGL::obtenirChaineGlVertexArray</a> () const</td></tr>
<tr class="memdesc:ga296737a05545afeefee6e3ff51fb9e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY.  <a href="#ga296737a05545afeefee6e3ff51fb9e9f">More...</a><br /></td></tr>
<tr class="separator:ga296737a05545afeefee6e3ff51fb9e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0230641b16e7addfb173d0bb2225f3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gace0230641b16e7addfb173d0bb2225f3">EtatOpenGL::obtenirChaineGlVertexArraySize</a> () const</td></tr>
<tr class="memdesc:gace0230641b16e7addfb173d0bb2225f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_SIZE.  <a href="#gace0230641b16e7addfb173d0bb2225f3">More...</a><br /></td></tr>
<tr class="separator:gace0230641b16e7addfb173d0bb2225f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720b3bc40a5ef124578f525b8f1e708f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga720b3bc40a5ef124578f525b8f1e708f">EtatOpenGL::obtenirChaineGlVertexArrayStride</a> () const</td></tr>
<tr class="memdesc:ga720b3bc40a5ef124578f525b8f1e708f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_STRIDE.  <a href="#ga720b3bc40a5ef124578f525b8f1e708f">More...</a><br /></td></tr>
<tr class="separator:ga720b3bc40a5ef124578f525b8f1e708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddbd22deaf3a7f5e0af66a3b0145a05f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gaddbd22deaf3a7f5e0af66a3b0145a05f">EtatOpenGL::obtenirChaineGlVertexArrayType</a> () const</td></tr>
<tr class="memdesc:gaddbd22deaf3a7f5e0af66a3b0145a05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_TYPE.  <a href="#gaddbd22deaf3a7f5e0af66a3b0145a05f">More...</a><br /></td></tr>
<tr class="separator:gaddbd22deaf3a7f5e0af66a3b0145a05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ecb164eb134e30a37a9928ea2a0e93"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga24ecb164eb134e30a37a9928ea2a0e93">EtatOpenGL::obtenirChaineGlViewport</a> () const</td></tr>
<tr class="memdesc:ga24ecb164eb134e30a37a9928ea2a0e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_VIEWPORT.  <a href="#ga24ecb164eb134e30a37a9928ea2a0e93">More...</a><br /></td></tr>
<tr class="separator:ga24ecb164eb134e30a37a9928ea2a0e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa724bf6cfbd4b0401c41c854ff06fcd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#gafa724bf6cfbd4b0401c41c854ff06fcd">EtatOpenGL::obtenirChaineGlZoomX</a> () const</td></tr>
<tr class="memdesc:gafa724bf6cfbd4b0401c41c854ff06fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ZOOM_X.  <a href="#gafa724bf6cfbd4b0401c41c854ff06fcd">More...</a><br /></td></tr>
<tr class="separator:gafa724bf6cfbd4b0401c41c854ff06fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d07131212785e91285ea82bbba15f7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga87d07131212785e91285ea82bbba15f7">EtatOpenGL::obtenirChaineGlZoomY</a> () const</td></tr>
<tr class="memdesc:ga87d07131212785e91285ea82bbba15f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne une chaîne représentant l'attribut GL_ZOOM_Y.  <a href="#ga87d07131212785e91285ea82bbba15f7">More...</a><br /></td></tr>
<tr class="separator:ga87d07131212785e91285ea82bbba15f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fa66cf904b19e12643fa88cc8ee5d5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga37fa66cf904b19e12643fa88cc8ee5d5"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga37fa66cf904b19e12643fa88cc8ee5d5">EtatOpenGL::obtenirChaineVecteur</a> (const T *v, int size)</td></tr>
<tr class="memdesc:ga37fa66cf904b19e12643fa88cc8ee5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction qui retourne la chaîne d'un vecteur de valeurs.  <a href="#ga37fa66cf904b19e12643fa88cc8ee5d5">More...</a><br /></td></tr>
<tr class="separator:ga37fa66cf904b19e12643fa88cc8ee5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a4ea49db400340eebc4862b6fbf759"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga15a4ea49db400340eebc4862b6fbf759">EtatOpenGL::obtenirChaineBooleen</a> (GLboolean v)</td></tr>
<tr class="memdesc:ga15a4ea49db400340eebc4862b6fbf759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction qui affiche une valeur booléenne d'<a class="el" href="namespace_open_g_l.html">OpenGL</a>.  <a href="#ga15a4ea49db400340eebc4862b6fbf759">More...</a><br /></td></tr>
<tr class="separator:ga15a4ea49db400340eebc4862b6fbf759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga349c289d77c484b8b4a180843d968b46"><td class="memItemLeft" align="right" valign="top">static T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga349c289d77c484b8b4a180843d968b46">Singleton&lt; T &gt;::obtenirInstance</a> ()</td></tr>
<tr class="memdesc:ga349c289d77c484b8b4a180843d968b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtient l'instance unique de la classe.  <a href="#ga349c289d77c484b8b4a180843d968b46">More...</a><br /></td></tr>
<tr class="separator:ga349c289d77c484b8b4a180843d968b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9ae943a004663d769be3f08ae35a0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilitaire.html#ga2b9ae943a004663d769be3f08ae35a0f">Singleton&lt; T &gt;::libererInstance</a> ()</td></tr>
<tr class="memdesc:ga2b9ae943a004663d769be3f08ae35a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Libère l'instance unique de la classe.  <a href="#ga2b9ae943a004663d769be3f08ae35a0f">More...</a><br /></td></tr>
<tr class="separator:ga2b9ae943a004663d769be3f08ae35a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacd82c66571930dca394095824ff37a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd82c66571930dca394095824ff37a5c">&sect;&nbsp;</a></span>COMPARER_DEFAUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPARER_DEFAUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;return &quot;GL_??? (&quot; + utilitaire::convertirEnChaine(x) + &quot;)&quot;;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette macro retourne la valeur par défaut de la variable. </p>

</div>
</div>
<a id="ga849df54224f798741d3fe046180dddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga849df54224f798741d3fe046180dddfc">&sect;&nbsp;</a></span>COMPARER_VALEUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPARER_VALEUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chaine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if (x == chaine) return #chaine ;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cette macro permet de retourner la chaîne associée à une valeur. </p>

</div>
</div>
<a id="gae90f81f48642444b4ba7fa5cacf40569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae90f81f48642444b4ba7fa5cacf40569">&sect;&nbsp;</a></span>GL_CLAMP_TO_EDGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GL_CLAMP_TO_EDGE&#160;&#160;&#160;0x812F</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9f918755b601cf4bffca775992e6fb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f918755b601cf4bffca775992e6fb90">&sect;&nbsp;</a></span>NOMINMAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOMINMAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force à ne pas inclure les macros min et max de windows.h. </p>

</div>
</div>
<a id="ga1e4ee9d5709f277c392eea80755d85d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e4ee9d5709f277c392eea80755d85d0">&sect;&nbsp;</a></span>SINGLETON_DECLARATION_CLASSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SINGLETON_DECLARATION_CLASSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Classe</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">private</span>:                                     \</div><div class="line">    Classe() {}                              \</div><div class="line">    ~Classe() {}                            \</div><div class="line">    Classe(<span class="keyword">const</span> Classe&amp;);                 \</div><div class="line">    Classe &amp; operator = (<span class="keyword">const</span> Classe&amp;);    \</div><div class="line">    friend <span class="keyword">class </span><a class="code" href="class_singleton.html">Singleton</a>&lt; Classe &gt;;         \</div><div class="ttc" id="class_singleton_html"><div class="ttname"><a href="class_singleton.html">Singleton</a></div><div class="ttdoc">Cette classe représente une base générique pour la déclaration de singleton. </div><div class="ttdef"><b>Definition:</b> Singleton.h:28</div></div>
</div><!-- fragment --><p>Cette macro doit être incluse dans les classes dérivées de <a class="el" href="class_singleton.html" title="Cette classe représente une base générique pour la déclaration de singleton. ">Singleton</a>. Elle déclare les constructeurs et destructeurs privés. </p>

</div>
</div>
<a id="ga4e5462d4b058b18eaee177c1f3f50964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5462d4b058b18eaee177c1f3f50964">&sect;&nbsp;</a></span>SINGLETON_DECLARATION_CLASSE_SANS_CONSTRUCTEUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SINGLETON_DECLARATION_CLASSE_SANS_CONSTRUCTEUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Classe</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">private</span>:                                                       \</div><div class="line">    Classe(<span class="keyword">const</span> Classe&amp;);                                  \</div><div class="line">    Classe&amp; <a class="code" href="class_singleton.html#a0765f17c275d65bacc1aae955e9bfc95">operator=</a>(<span class="keyword">const</span> Classe&amp;);                     \</div><div class="line">    friend <span class="keyword">class </span><a class="code" href="class_singleton.html">Singleton</a>&lt; Classe &gt;;                           \</div><div class="ttc" id="class_singleton_html"><div class="ttname"><a href="class_singleton.html">Singleton</a></div><div class="ttdoc">Cette classe représente une base générique pour la déclaration de singleton. </div><div class="ttdef"><b>Definition:</b> Singleton.h:28</div></div>
<div class="ttc" id="class_singleton_html_a0765f17c275d65bacc1aae955e9bfc95"><div class="ttname"><a href="class_singleton.html#a0765f17c275d65bacc1aae955e9bfc95">Singleton::operator=</a></div><div class="ttdeci">Singleton &amp; operator=(const Singleton &amp;)=delete</div><div class="ttdoc">Opérateur d&amp;#39;assignation déclaré mais non défini. </div></div>
</div><!-- fragment --><p>Cette macro doit être incluse dans les classes dérivées de <a class="el" href="class_singleton.html" title="Cette classe représente une base générique pour la déclaration de singleton. ">Singleton</a>. Elle déclare le constructeur copie et l'opérateur d'assignation privé, en laissant à la classe dérivée le soin de définir le constructeur par défaut et le destructeur afin de faire le traitement souhaité. </p>

</div>
</div>
<a id="gafd88a0bb7182bc9164ab9200f31e6340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd88a0bb7182bc9164ab9200f31e6340">&sect;&nbsp;</a></span>SINGLETON_DECLARATION_CPP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SINGLETON_DECLARATION_CPP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Classe</td><td>)</td>
          <td>&#160;&#160;&#160;Classe * <a class="el" href="class_singleton.html">Singleton</a>&lt; Classe &gt;::instance_{ nullptr }; \</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4c476dc47b86b4ef9ff111febf1e6c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c476dc47b86b4ef9ff111febf1e6c7f">&sect;&nbsp;</a></span>VERTEX_LOCATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VERTEX_LOCATION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga53988236a3db0c0faa5eb1d8aa6a0742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53988236a3db0c0faa5eb1d8aa6a0742">&sect;&nbsp;</a></span>aiMatrix4x4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilitaire.html#ga53988236a3db0c0faa5eb1d8aa6a0742">aiMatrix4x4</a> =  <a class="el" href="classai_matrix4x4t.html">aiMatrix4x4t</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Déclaration avancée d'une classe. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5b5846202001fecd71cd2a0afbbdb494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b5846202001fecd71cd2a0afbbdb494">&sect;&nbsp;</a></span>CEcritureFichierBinaire() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CEcritureFichierBinaire::CEcritureFichierBinaire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par défaut. </p>
<p>Constructeur par défaut qui ne fait rien.</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a id="gad19b9753aa12a9f25fd0febc3c899024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad19b9753aa12a9f25fd0febc3c899024">&sect;&nbsp;</a></span>CEcritureFichierBinaire() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CEcritureFichierBinaire::CEcritureFichierBinaire </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nomFichier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::out&#160;|&#160;std::ios::binary</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par paramètre. </p>
<p>Constructeur par paramètres: ouvre un fichier binaire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nomFichier</td><td>: Le nom du fichier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>: Le mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a id="ga3a259905a2c14513846e6ecb8cf476ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a259905a2c14513846e6ecb8cf476ad">&sect;&nbsp;</a></span>CLectureFichierBinaire() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLectureFichierBinaire::CLectureFichierBinaire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par défaut. </p>
<p>Constructeur par défaut qui ne fait rien.</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a id="gac16ebab7b172408c2ba14605f61f0f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac16ebab7b172408c2ba14605f61f0f84">&sect;&nbsp;</a></span>CLectureFichierBinaire() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLectureFichierBinaire::CLectureFichierBinaire </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nomFichier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios::in&#160;|&#160;std::ios::binary</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par paramètre. </p>
<p>Constructeur par paramètres: ouvre un fichier binaire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nomFichier</td><td>: Le nom du fichier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>: Le mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aucune </dd></dl>

</div>
</div>
<a id="gaf682f61929f2502b08b6b88de07349b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf682f61929f2502b08b6b88de07349b6">&sect;&nbsp;</a></span>EtatOpenGL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EtatOpenGL::EtatOpenGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par défaut. </p>
<p>Ce constructeur lit toutes ses variables de l'état courant de la machine <a class="el" href="namespace_open_g_l.html">OpenGL</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune (constructeur). </dd></dl>

</div>
</div>
<a id="ga2b9ae943a004663d769be3f08ae35a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b9ae943a004663d769be3f08ae35a0f">&sect;&nbsp;</a></span>libererInstance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_singleton.html">Singleton</a>&lt; T &gt;::libererInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Libère l'instance unique de la classe. </p>
<p>Détruit l'instance unique de la classe. Cette fonction n'est pas "thread-safe".</p>
<dl class="section return"><dt>Returns</dt><dd>Aucune. </dd></dl>

</div>
</div>
<a id="ga7145545254c30909311d3b1ef0bdd07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7145545254c30909311d3b1ef0bdd07a">&sect;&nbsp;</a></span>null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CEcritureFichierBinaire::null </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction pour insérer des caractères vides dans le fichier. </p>
<p>Cette fonction permet d'insérer des caractèrs nuls (0) dans le fichier binaire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: Le nombre de caractères vides à insérer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aucune </dd></dl>

</div>
</div>
<a id="ga15a4ea49db400340eebc4862b6fbf759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a4ea49db400340eebc4862b6fbf759">&sect;&nbsp;</a></span>obtenirChaineBooleen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineBooleen </td>
          <td>(</td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fonction qui affiche une valeur booléenne d'<a class="el" href="namespace_open_g_l.html">OpenGL</a>. </p>
<p>Cette fonction retourne une chaîne représentant un attribut qui est une valeur booléenne.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: L'attribut booléen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut booléen. </dd></dl>

</div>
</div>
<a id="gaa8656cbeda0f2ed712d9011abf508e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8656cbeda0f2ed712d9011abf508e57">&sect;&nbsp;</a></span>obtenirChaineGlAccumAlphaBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAccumAlphaBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ACCUM_ALPHA_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ACCUM_ALPHA_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of alpha bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ACCUM_ALPHA_BITS. </dd></dl>

</div>
</div>
<a id="ga7dbb4a62b0b523eeedca913830f31f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dbb4a62b0b523eeedca913830f31f1b">&sect;&nbsp;</a></span>obtenirChaineGlAccumBlueBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAccumBlueBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ACCUM_BLUE_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ACCUM_BLUE_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of blue bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ACCUM_BLUE_BITS. </dd></dl>

</div>
</div>
<a id="gafd8c270275c56c28b245cdfd36382564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8c270275c56c28b245cdfd36382564">&sect;&nbsp;</a></span>obtenirChaineGlAccumClearValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAccumClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ACCUM_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ACCUM_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values used to clear the accumulation buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glClearAccum.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ACCUM_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a id="ga5ad3c3edbf3e81b25319385d46ec27a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ad3c3edbf3e81b25319385d46ec27a4">&sect;&nbsp;</a></span>obtenirChaineGlAccumGreenBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAccumGreenBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ACCUM_GREEN_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ACCUM_GREEN_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of green bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ACCUM_GREEN_BITS. </dd></dl>

</div>
</div>
<a id="ga993cdc1ff7f7e5455208a48872f8b60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga993cdc1ff7f7e5455208a48872f8b60a">&sect;&nbsp;</a></span>obtenirChaineGlAccumRedBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAccumRedBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ACCUM_RED_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ACCUM_RED_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of red bitplanes in the accumulation buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ACCUM_RED_BITS. </dd></dl>

</div>
</div>
<a id="ga46c4d8c91afe67877586b679872dc623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46c4d8c91afe67877586b679872dc623">&sect;&nbsp;</a></span>obtenirChaineGlAlphaBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAlphaBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ALPHA_BIAS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ALPHA_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the alpha bias factor used during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ALPHA_BIAS. </dd></dl>

</div>
</div>
<a id="gad2ad2bee7735604cafceab92693f9e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2ad2bee7735604cafceab92693f9e11">&sect;&nbsp;</a></span>obtenirChaineGlAlphaBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAlphaBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ALPHA_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ALPHA_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of alpha bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ALPHA_BITS. </dd></dl>

</div>
</div>
<a id="gaae9954ff46bf1c58149d829b76f8db41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae9954ff46bf1c58149d829b76f8db41">&sect;&nbsp;</a></span>obtenirChaineGlAlphaScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAlphaScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ALPHA_SCALE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ALPHA_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the alpha scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ALPHA_SCALE. </dd></dl>

</div>
</div>
<a id="ga7b2625ee169f3e5c1c23340fd1a2b7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b2625ee169f3e5c1c23340fd1a2b7d4">&sect;&nbsp;</a></span>obtenirChaineGlAlphaTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAlphaTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ALPHA_TEST. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ALPHA_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether alpha testing of fragments is enabled. The initial value is GL_FALSE. See glAlphaFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ALPHA_TEST. </dd></dl>

</div>
</div>
<a id="gabde25f2a3f9f1498b01b0b1c6ead8cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabde25f2a3f9f1498b01b0b1c6ead8cd6">&sect;&nbsp;</a></span>obtenirChaineGlAlphaTestFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAlphaTestFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ALPHA_TEST_FUNC. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ALPHA_TEST_FUNC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic name of the alpha test function. The initial value is GL_ALWAYS. See glAlphaFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ALPHA_TEST_FUNC. </dd></dl>

</div>
</div>
<a id="ga8100b417d2a68024951ae1870e3c8ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8100b417d2a68024951ae1870e3c8ce9">&sect;&nbsp;</a></span>obtenirChaineGlAlphaTestRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAlphaTestRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ALPHA_TEST_REF. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ALPHA_TEST_REF.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the reference value for the alpha test. The initial value is 0. See glAlphaFunc. An integer value, if requested, is linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ALPHA_TEST_REF. </dd></dl>

</div>
</div>
<a id="ga05ae7261196ab97cafdee0bd8f388814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05ae7261196ab97cafdee0bd8f388814">&sect;&nbsp;</a></span>obtenirChaineGlAttribStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the depth of the attribute stack. If the stack is empty, 0 is returned. The initial value is 0. See glPushAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="ga4cb68c8068c33f061ba4e2f5a18fe58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cb68c8068c33f061ba4e2f5a18fe58a">&sect;&nbsp;</a></span>obtenirChaineGlAutoNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAutoNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_AUTO_NORMAL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_AUTO_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D map evaluation automatically generates surface normals. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_AUTO_NORMAL. </dd></dl>

</div>
</div>
<a id="ga9f7ed9e063fd7cd322ead2b920ad76d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f7ed9e063fd7cd322ead2b920ad76d3">&sect;&nbsp;</a></span>obtenirChaineGlAuxBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlAuxBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_AUX_BUFFERS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_AUX_BUFFERS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of auxiliary color buffers. The initial value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_AUX_BUFFERS. </dd></dl>

</div>
</div>
<a id="gad2714438ed8a3bbcfae6788452c41fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2714438ed8a3bbcfae6788452c41fc2">&sect;&nbsp;</a></span>obtenirChaineGlBlend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlBlend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_BLEND. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_BLEND.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether blending is enabled. The initial value is GL_FALSE. See glBlendFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_BLEND. </dd></dl>

</div>
</div>
<a id="ga7e1d97b60cea47ff94c43cb7fe5549de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e1d97b60cea47ff94c43cb7fe5549de">&sect;&nbsp;</a></span>obtenirChaineGlBlendDst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlBlendDst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_BLEND_DST. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_BLEND_DST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic constant identifying the destination blend function. The initial value is GL_ZERO. See glBlendFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_BLEND_DST. </dd></dl>

</div>
</div>
<a id="ga72f762cf26215a0596f0f1e199054a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72f762cf26215a0596f0f1e199054a6a">&sect;&nbsp;</a></span>obtenirChaineGlBlendSrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlBlendSrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_BLEND_SRC. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_BLEND_SRC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic constant identifying the source blend function. The initial value is GL_ONE. See glBlendFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_BLEND_SRC. </dd></dl>

</div>
</div>
<a id="gac365fb32df160a1c96a2a83a1c366c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac365fb32df160a1c96a2a83a1c366c6a">&sect;&nbsp;</a></span>obtenirChaineGlBlueBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlBlueBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_BLUE_BIAS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_BLUE_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the blue bias factor used during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_BLUE_BIAS. </dd></dl>

</div>
</div>
<a id="ga256b4aa3305c8c45df1d1e69e9371251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga256b4aa3305c8c45df1d1e69e9371251">&sect;&nbsp;</a></span>obtenirChaineGlBlueBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlBlueBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_BLUE_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_BLUE_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of blue bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_BLUE_BITS. </dd></dl>

</div>
</div>
<a id="ga1705991ab059f889107b13b6d2143309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1705991ab059f889107b13b6d2143309">&sect;&nbsp;</a></span>obtenirChaineGlBlueScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlBlueScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_BLUE_SCALE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_BLUE_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the blue scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_BLUE_SCALE. </dd></dl>

</div>
</div>
<a id="gab7118bfe505a235920434b0b9b0ddb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7118bfe505a235920434b0b9b0ddb5f">&sect;&nbsp;</a></span>obtenirChaineGlClientAttribStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlClientAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value indicating the depth of the attribute stack. The initial value is 0. See glPushClientAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CLIENT_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="ga4bd5df42f81d3138c7a5740a3ccf8e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bd5df42f81d3138c7a5740a3ccf8e11">&sect;&nbsp;</a></span>obtenirChaineGlClipPlanei()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlClipPlanei </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CLIP_PLANEi. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CLIP_PLANEi.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the specified clipping plane is enabled. The initial value is GL_FALSE. See glClipPlane.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CLIP_PLANEi. </dd></dl>

</div>
</div>
<a id="ga3286196d8d748b5d71d60edac17e28be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3286196d8d748b5d71d60edac17e28be">&sect;&nbsp;</a></span>obtenirChaineGlColorArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlColorArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_COLOR_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the color array is enabled. The initial value is GL_FALSE. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_COLOR_ARRAY. </dd></dl>

</div>
</div>
<a id="gac10b04c597d6737e387389bebf9d6ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10b04c597d6737e387389bebf9d6ca7">&sect;&nbsp;</a></span>obtenirChaineGlColorArraySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlColorArraySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of components per color in the color array. The initial value is 4. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_COLOR_ARRAY_SIZE. </dd></dl>

</div>
</div>
<a id="ga3ca446a9fe965203bf9dbc42d4864f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ca446a9fe965203bf9dbc42d4864f0a">&sect;&nbsp;</a></span>obtenirChaineGlColorArrayStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlColorArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive colors in the color array. The initial value is 0. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_COLOR_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a id="gad413af6e274e71639b0d6835c7b7c2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad413af6e274e71639b0d6835c7b7c2bd">&sect;&nbsp;</a></span>obtenirChaineGlColorArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlColorArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_COLOR_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of each component in the color array. The initial value is GL_FLOAT. See glColorPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_COLOR_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a id="gaaae0db2c8013a921e847549ade2c0ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaae0db2c8013a921e847549ade2c0ca6">&sect;&nbsp;</a></span>obtenirChaineGlColorClearValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlColorClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_COLOR_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_COLOR_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glClearColor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_COLOR_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a id="gaee252aa711178229a58d3fd6c43c5de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee252aa711178229a58d3fd6c43c5de2">&sect;&nbsp;</a></span>obtenirChaineGlColorLogicOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlColorLogicOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_COLOR_LOGIC_OP. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_COLOR_LOGIC_OP.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is GL_FALSE. See glLogicOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_COLOR_LOGIC_OP. </dd></dl>

</div>
</div>
<a id="ga59e1deb995eafcfa552e9be15e08505a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e1deb995eafcfa552e9be15e08505a">&sect;&nbsp;</a></span>obtenirChaineGlColorWritemask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlColorWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_COLOR_WRITEMASK. </p>

</div>
</div>
<a id="gad93ae0b0eca875fc037af17b44555072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad93ae0b0eca875fc037af17b44555072">&sect;&nbsp;</a></span>obtenirChaineGlCullFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCullFace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CULL_FACE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CULL_FACE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon culling is enabled. The initial value is GL_FALSE. See glCullFace.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CULL_FACE. </dd></dl>

</div>
</div>
<a id="ga94b60c9393c3457e1107ad7ec1f8d062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94b60c9393c3457e1107ad7ec1f8d062">&sect;&nbsp;</a></span>obtenirChaineGlCullFaceMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCullFaceMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CULL_FACE_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CULL_FACE_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which polygon faces are to be culled. The initial value is GL_BACK. See glCullFace.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CULL_FACE_MODE. </dd></dl>

</div>
</div>
<a id="ga20884239fb1a60946172566ca0bca365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20884239fb1a60946172566ca0bca365">&sect;&nbsp;</a></span>obtenirChaineGlCurrentColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_COLOR. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values of the current color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See glColor. The initial value is (1, 1, 1, 1).</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_COLOR. </dd></dl>

</div>
</div>
<a id="gaabe68db66d3915cd5f0f77d538acf2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabe68db66d3915cd5f0f77d538acf2a6">&sect;&nbsp;</a></span>obtenirChaineGlCurrentIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_INDEX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the current color index. The initial value is 1. See glIndex.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_INDEX. </dd></dl>

</div>
</div>
<a id="ga75bf3164a953e74dc9326e90cf7c8d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75bf3164a953e74dc9326e90cf7c8d85">&sect;&nbsp;</a></span>obtenirChaineGlCurrentNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_NORMAL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns three values: the x, y, and z values of the current normal. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 1). See glNormal.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_NORMAL. </dd></dl>

</div>
</div>
<a id="ga3314105ec05d0f70813c7e9ec0e38640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3314105ec05d0f70813c7e9ec0e38640">&sect;&nbsp;</a></span>obtenirChaineGlCurrentRasterColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentRasterColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_COLOR. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha values of the current raster position. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (1, 1, 1, 1). See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_RASTER_COLOR. </dd></dl>

</div>
</div>
<a id="gadbbc64055237c25eb1e48f3c72bcd049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbbc64055237c25eb1e48f3c72bcd049">&sect;&nbsp;</a></span>obtenirChaineGlCurrentRasterDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentRasterDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_DISTANCE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_DISTANCE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the distance from the eye to the current raster position. The initial value is 0. See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_RASTER_DISTANCE. </dd></dl>

</div>
</div>
<a id="ga7cc3033052636dc0508fdaeefc900e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc3033052636dc0508fdaeefc900e24">&sect;&nbsp;</a></span>obtenirChaineGlCurrentRasterIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentRasterIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_INDEX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the color index of the current raster position. The initial value is 1. See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_RASTER_INDEX. </dd></dl>

</div>
</div>
<a id="gae3dd2ee0e0ae262480c05c68a671c033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3dd2ee0e0ae262480c05c68a671c033">&sect;&nbsp;</a></span>obtenirChaineGlCurrentRasterPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentRasterPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the x, y, z, and w components of the current raster position. x, y, and z are in window coordinates, and w is in clip coordinates. The initial value is (0, 0, 0, 1). See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION. </dd></dl>

</div>
</div>
<a id="ga94408d6f73fe9c70c0460675bfe80e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94408d6f73fe9c70c0460675bfe80e86">&sect;&nbsp;</a></span>obtenirChaineGlCurrentRasterPositionValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentRasterPositionValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION_VALID. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION_VALID.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the current raster position is valid. The initial value is GL_TRUE. See glRasterPos.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_RASTER_POSITION_VALID. </dd></dl>

</div>
</div>
<a id="gae1517a5b7f85128f7975d2ed22f2a41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1517a5b7f85128f7975d2ed22f2a41a">&sect;&nbsp;</a></span>obtenirChaineGlCurrentRasterTextureCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentRasterTextureCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the s, t, r, and q current raster texture coordinates. The initial value is (0, 0, 0, 1). See glRasterPos and glTexCoord.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_RASTER_TEXTURE_COORDS. </dd></dl>

</div>
</div>
<a id="gaa1d9dc43fb9d85437a9a14b9cfa8d404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d9dc43fb9d85437a9a14b9cfa8d404">&sect;&nbsp;</a></span>obtenirChaineGlCurrentTextureCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlCurrentTextureCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_CURRENT_TEXTURE_COORDS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_CURRENT_TEXTURE_COORDS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the s, t, r, and q current texture coordinates. The initial value is (0, 0, 0, 1). See glTexCoord.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_CURRENT_TEXTURE_COORDS. </dd></dl>

</div>
</div>
<a id="ga21e04321a436f388c626d2f529c3c185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21e04321a436f388c626d2f529c3c185">&sect;&nbsp;</a></span>obtenirChaineGlDepthBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_BIAS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the depth bias factor used during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_BIAS. </dd></dl>

</div>
</div>
<a id="gae0e44f1891bae7fc43c7a12a8b71fc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0e44f1891bae7fc43c7a12a8b71fc52">&sect;&nbsp;</a></span>obtenirChaineGlDepthBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of bitplanes in the depth buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_BITS. </dd></dl>

</div>
</div>
<a id="ga9515e1564287dae37c509a4b17336c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9515e1564287dae37c509a4b17336c2d">&sect;&nbsp;</a></span>obtenirChaineGlDepthClearValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See glClearDepth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a id="gae5bc5e5d75634f402e8f24d93e1caa1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5bc5e5d75634f402e8f24d93e1caa1b">&sect;&nbsp;</a></span>obtenirChaineGlDepthFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_FUNC. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_FUNC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the symbolic constant that indicates the depth comparison function. The initial value is GL_LESS. See glDepthFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_FUNC. </dd></dl>

</div>
</div>
<a id="ga85e6a94d0619baaf53a89bbf2f550622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e6a94d0619baaf53a89bbf2f550622">&sect;&nbsp;</a></span>obtenirChaineGlDepthRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_RANGE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_RANGE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 1). See glDepthRange.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_RANGE. </dd></dl>

</div>
</div>
<a id="ga7209dac0d5a1874b02c72e82c4d2c955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7209dac0d5a1874b02c72e82c4d2c955">&sect;&nbsp;</a></span>obtenirChaineGlDepthScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_SCALE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the depth scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_SCALE. </dd></dl>

</div>
</div>
<a id="ga0c24c37fa70752f2c69d4276ef849c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c24c37fa70752f2c69d4276ef849c97">&sect;&nbsp;</a></span>obtenirChaineGlDepthTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_TEST. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is GL_FALSE. See glDepthFunc and glDepthRange.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_TEST. </dd></dl>

</div>
</div>
<a id="gaa77e7c295b2e35fa4d3fe85d30bce33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa77e7c295b2e35fa4d3fe85d30bce33a">&sect;&nbsp;</a></span>obtenirChaineGlDepthWritemask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDepthWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DEPTH_WRITEMASK. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DEPTH_WRITEMASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is GL_TRUE. See glDepthMask.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DEPTH_WRITEMASK. </dd></dl>

</div>
</div>
<a id="gad8275ab093f85a85e79ef7ccf1ba4a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8275ab093f85a85e79ef7ccf1ba4a83">&sect;&nbsp;</a></span>obtenirChaineGlDither()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDither </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DITHER. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DITHER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is GL_TRUE.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DITHER. </dd></dl>

</div>
</div>
<a id="gaad85cc7827f114c6477b91741e404c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad85cc7827f114c6477b91741e404c3a">&sect;&nbsp;</a></span>obtenirChaineGlDoublebuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDoublebuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DOUBLEBUFFER. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DOUBLEBUFFER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether double buffering is supported.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DOUBLEBUFFER. </dd></dl>

</div>
</div>
<a id="ga9f97ba97f9f390b2cb307a2253e7817a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f97ba97f9f390b2cb307a2253e7817a">&sect;&nbsp;</a></span>obtenirChaineGlDrawBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlDrawBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_DRAW_BUFFER. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_DRAW_BUFFER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which buffers are being drawn to. See glDrawBuffer. The initial value is GL_BACK if there are back buffers, otherwise it is GL_FRONT.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_DRAW_BUFFER. </dd></dl>

</div>
</div>
<a id="gabd6bd412fc0e4cc38ac7c146843a5b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd6bd412fc0e4cc38ac7c146843a5b72">&sect;&nbsp;</a></span>obtenirChaineGlEdgeFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlEdgeFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_EDGE_FLAG. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_EDGE_FLAG.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the current edge flag is GL_TRUE or GL_FALSE. The initial value is GL_TRUE. See glEdgeFlag.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_EDGE_FLAG. </dd></dl>

</div>
</div>
<a id="ga72ea8b2938944cc1a4e9dbb7a4ad5bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ea8b2938944cc1a4e9dbb7a4ad5bce">&sect;&nbsp;</a></span>obtenirChaineGlEdgeFlagArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlEdgeFlagArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the edge flag array is enabled. The initial value is GL_FALSE. See glEdgeFlagPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY. </dd></dl>

</div>
</div>
<a id="gab483fd765edeb5933dea413939b52a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab483fd765edeb5933dea413939b52a10">&sect;&nbsp;</a></span>obtenirChaineGlEdgeFlagArrayStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlEdgeFlagArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive edge flags in the edge flag array. The initial value is 0. See glEdgeFlagPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_EDGE_FLAG_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a id="gaf7753e66d86737b2a85d5e6f95fd4aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7753e66d86737b2a85d5e6f95fd4aea">&sect;&nbsp;</a></span>obtenirChaineGlFeedbackBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFeedbackBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the feedback buffer. See glFeedbackBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_SIZE. </dd></dl>

</div>
</div>
<a id="ga814db73f45f9df7ccf50acc6e59bdaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814db73f45f9df7ccf50acc6e59bdaaf">&sect;&nbsp;</a></span>obtenirChaineGlFeedbackBufferType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFeedbackBufferType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_TYPE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the type of the feedback buffer. See glFeedbackBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FEEDBACK_BUFFER_TYPE. </dd></dl>

</div>
</div>
<a id="gac8e8d960775b0eb966c82afb9ddb52e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8e8d960775b0eb966c82afb9ddb52e0">&sect;&nbsp;</a></span>obtenirChaineGlFog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether fogging is enabled. The initial value is GL_FALSE. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG. </dd></dl>

</div>
</div>
<a id="ga784b74f0e9d60221fd19cc10b79bc69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga784b74f0e9d60221fd19cc10b79bc69d">&sect;&nbsp;</a></span>obtenirChaineGlFogColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFogColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG_COLOR. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the red, green, blue, and alpha components of the fog color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG_COLOR. </dd></dl>

</div>
</div>
<a id="ga60cd91f196312ca03714055d8157f000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60cd91f196312ca03714055d8157f000">&sect;&nbsp;</a></span>obtenirChaineGlFogDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFogDensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG_DENSITY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG_DENSITY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the fog density parameter. The initial value is</p><ol type="1">
<li>See glFog.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG_DENSITY. </dd></dl>

</div>
</div>
<a id="ga5e6ae47c747ef2901079b883242a816c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e6ae47c747ef2901079b883242a816c">&sect;&nbsp;</a></span>obtenirChaineGlFogEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFogEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG_END. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG_END.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the end factor for the linear fog equation. The initial value is 1. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG_END. </dd></dl>

</div>
</div>
<a id="ga6e0463757220fb3c7578405fb59a6820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e0463757220fb3c7578405fb59a6820">&sect;&nbsp;</a></span>obtenirChaineGlFogHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFogHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG_HINT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the fog hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG_HINT. </dd></dl>

</div>
</div>
<a id="gad272f3a0b0f28ccc317f2a1e0b14855f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad272f3a0b0f28ccc317f2a1e0b14855f">&sect;&nbsp;</a></span>obtenirChaineGlFogIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFogIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG_INDEX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the fog color index. The initial value is 0. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG_INDEX. </dd></dl>

</div>
</div>
<a id="ga04a79598a8474e1708000380deb7dd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a79598a8474e1708000380deb7dd7f">&sect;&nbsp;</a></span>obtenirChaineGlFogMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFogMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which fog equation is selected. The initial value is GL_EXP. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG_MODE. </dd></dl>

</div>
</div>
<a id="gafa12c7dcadecd93fb0b8341ae0757cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa12c7dcadecd93fb0b8341ae0757cdf">&sect;&nbsp;</a></span>obtenirChaineGlFogStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFogStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FOG_START. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FOG_START.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the start factor for the linear fog equation. The initial value is 0. See glFog.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FOG_START. </dd></dl>

</div>
</div>
<a id="ga5efc4362a72db2431bf2d2e7bac4d977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5efc4362a72db2431bf2d2e7bac4d977">&sect;&nbsp;</a></span>obtenirChaineGlFrontFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlFrontFace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_FRONT_FACE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_FRONT_FACE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating whether clockwise or counterclockwise polygon winding is treated as front-facing. The initial value is GL_CCW. See glFrontFace.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_FRONT_FACE. </dd></dl>

</div>
</div>
<a id="ga840850c6c20df7baa91e455f762f70f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga840850c6c20df7baa91e455f762f70f1">&sect;&nbsp;</a></span>obtenirChaineGlGreenBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlGreenBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_GREEN_BIAS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_GREEN_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the green bias factor used during pixel transfers. The initial value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_GREEN_BIAS. </dd></dl>

</div>
</div>
<a id="gab00241b05a45ab2c548b32e19f260765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab00241b05a45ab2c548b32e19f260765">&sect;&nbsp;</a></span>obtenirChaineGlGreenBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlGreenBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_GREEN_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_GREEN_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of green bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_GREEN_BITS. </dd></dl>

</div>
</div>
<a id="ga89d85fd92f39ab3e1127d793ed6bd544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d85fd92f39ab3e1127d793ed6bd544">&sect;&nbsp;</a></span>obtenirChaineGlGreenScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlGreenScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_GREEN_SCALE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_GREEN_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the green scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_GREEN_SCALE. </dd></dl>

</div>
</div>
<a id="gaa0c6db97e881cd2c6c84a94cc7988a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c6db97e881cd2c6c84a94cc7988a77">&sect;&nbsp;</a></span>obtenirChaineGlIndexArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_ARRAY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the color index array is enabled. The initial value is GL_FALSE. See glIndexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_ARRAY. </dd></dl>

</div>
</div>
<a id="ga06dc22d7c82113165287539883874cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06dc22d7c82113165287539883874cb5">&sect;&nbsp;</a></span>obtenirChaineGlIndexArrayStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive color indexes in the color index array. The initial value is 0. See glIndexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a id="ga62a8715e0f8b2c26af13b7c72f91d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62a8715e0f8b2c26af13b7c72f91d3c3">&sect;&nbsp;</a></span>obtenirChaineGlIndexArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of indexes in the color index array. The initial value is GL_FLOAT. See glIndexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a id="ga95369618151bee71fe60a9b7b04ef794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95369618151bee71fe60a9b7b04ef794">&sect;&nbsp;</a></span>obtenirChaineGlIndexBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of bitplanes in each color index buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_BITS. </dd></dl>

</div>
</div>
<a id="ga7d3ab756b3c7fd8ad3ca83019559dfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d3ab756b3c7fd8ad3ca83019559dfb6">&sect;&nbsp;</a></span>obtenirChaineGlIndexClearValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the color index used to clear the color index buffers. The initial value is 0. See glClearIndex.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a id="ga6a6fe84e8d9d4328d989ba8eea4028c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6fe84e8d9d4328d989ba8eea4028c1">&sect;&nbsp;</a></span>obtenirChaineGlIndexLogicOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexLogicOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_LOGIC_OP. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_LOGIC_OP.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether a fragment's index values are merged into the framebuffer using a logical operation. The initial value is GL_FALSE. See glLogicOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_LOGIC_OP. </dd></dl>

</div>
</div>
<a id="ga5d6bec756899c6ca51948747fd0ef688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d6bec756899c6ca51948747fd0ef688">&sect;&nbsp;</a></span>obtenirChaineGlIndexMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the GL is in color index mode (GL_TRUE) or RGBA mode (GL_FALSE).</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_MODE. </dd></dl>

</div>
</div>
<a id="ga89c2361922e4a390cb6ea98b899666a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89c2361922e4a390cb6ea98b899666a1">&sect;&nbsp;</a></span>obtenirChaineGlIndexOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_OFFSET. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_OFFSET.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the offset added to color and stencil indices during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_OFFSET. </dd></dl>

</div>
</div>
<a id="ga024563c27e484b25158053c5d17d65ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024563c27e484b25158053c5d17d65ed">&sect;&nbsp;</a></span>obtenirChaineGlIndexShift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexShift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_SHIFT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_SHIFT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the amount that color and stencil indices are shifted during pixel transfers. The initial value is 0. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_SHIFT. </dd></dl>

</div>
</div>
<a id="ga4bf831e8c9f908dfad12a6fa59414e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf831e8c9f908dfad12a6fa59414e78">&sect;&nbsp;</a></span>obtenirChaineGlIndexWritemask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlIndexWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_INDEX_WRITEMASK. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_INDEX_WRITEMASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a mask indicating which bitplanes of each color index buffer can be written. The initial value is all 1's. See glIndexMask.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_INDEX_WRITEMASK. </dd></dl>

</div>
</div>
<a id="ga7f0d748f174bf87954aa5464ff7db4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f0d748f174bf87954aa5464ff7db4ef">&sect;&nbsp;</a></span>obtenirChaineGlLineSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLineSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_SMOOTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_SMOOTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is GL_FALSE. See glLineWidth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_SMOOTH. </dd></dl>

</div>
</div>
<a id="gada0eec8ecca1691b24b5ea90fc0a72aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada0eec8ecca1691b24b5ea90fc0a72aa">&sect;&nbsp;</a></span>obtenirChaineGlLineSmoothHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLineSmoothHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_SMOOTH_HINT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_SMOOTH_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_SMOOTH_HINT. </dd></dl>

</div>
</div>
<a id="gab7ae8628605b7b1c223a724429e8cd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ae8628605b7b1c223a724429e8cd08">&sect;&nbsp;</a></span>obtenirChaineGlLineStipple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLineStipple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_STIPPLE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_STIPPLE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether stippling of lines is enabled. The initial value is GL_FALSE. See glLineStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_STIPPLE. </dd></dl>

</div>
</div>
<a id="ga7098806792020c69e9249e534f3993de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7098806792020c69e9249e534f3993de">&sect;&nbsp;</a></span>obtenirChaineGlLineStipplePattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLineStipplePattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_STIPPLE_PATTERN. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_STIPPLE_PATTERN.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the 16-bit line stipple pattern. The initial value is all 1's. See glLineStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_STIPPLE_PATTERN. </dd></dl>

</div>
</div>
<a id="gae36a7d44eca63a5d7b4b4201137a5ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae36a7d44eca63a5d7b4b4201137a5ec9">&sect;&nbsp;</a></span>obtenirChaineGlLineStippleRepeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLineStippleRepeat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_STIPPLE_REPEAT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_STIPPLE_REPEAT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the line stipple repeat factor. The initial value is 1. See glLineStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_STIPPLE_REPEAT. </dd></dl>

</div>
</div>
<a id="ga0b4e09903daa0907f3219edc0b54c3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4e09903daa0907f3219edc0b54c3c7">&sect;&nbsp;</a></span>obtenirChaineGlLineWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLineWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_WIDTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_WIDTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the line width as specified with glLineWidth. The initial value is 1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_WIDTH. </dd></dl>

</div>
</div>
<a id="ga4d8d43b3b084323284e0c6bd913b7a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d8d43b3b084323284e0c6bd913b7a7e">&sect;&nbsp;</a></span>obtenirChaineGlLineWidthGranularity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLineWidthGranularity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_WIDTH_GRANULARITY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_WIDTH_GRANULARITY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the width difference between adjacent supported widths for antialiased lines. See glLineWidth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_WIDTH_GRANULARITY. </dd></dl>

</div>
</div>
<a id="ga4042aa940e64993edf0339e4fe439820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4042aa940e64993edf0339e4fe439820">&sect;&nbsp;</a></span>obtenirChaineGllineWidthRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGllineWidthRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LINE_WIDTH_RANGE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LINE_WIDTH_RANGE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the smallest and largest supported widths for antialiased lines. See glLineWidth.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LINE_WIDTH_RANGE. </dd></dl>

</div>
</div>
<a id="gab4ef418485c6ac5343bd41c892c6cbae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4ef418485c6ac5343bd41c892c6cbae">&sect;&nbsp;</a></span>obtenirChaineGlListBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlListBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LIST_BASE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LIST_BASE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the base offset added to all names in arrays presented to glCallLists. The initial value is 0. See glListBase.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LIST_BASE. </dd></dl>

</div>
</div>
<a id="ga1ce2c5d4c226c53e6e4463d5e7acf35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ce2c5d4c226c53e6e4463d5e7acf35b">&sect;&nbsp;</a></span>obtenirChaineGlListIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlListIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LIST_INDEX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LIST_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the name of the display list currently under construction. 0 is returned if no display list is currently under construction. The initial value is 0. See glNewList.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LIST_INDEX. </dd></dl>

</div>
</div>
<a id="ga3b35e6ae2e52f70bf4b5196178d7bb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b35e6ae2e52f70bf4b5196178d7bb48">&sect;&nbsp;</a></span>obtenirChaineGlListMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlListMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LIST_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LIST_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the construction mode of the display list currently under construction. The initial value is 0. See glNewList.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LIST_MODE. </dd></dl>

</div>
</div>
<a id="ga374518f129ade463e34210c34f4fe967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374518f129ade463e34210c34f4fe967">&sect;&nbsp;</a></span>obtenirChaineGlLogicOpMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlLogicOpMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_LOGIC_OP_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_LOGIC_OP_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is GL_COPY. See glLogicOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_LOGIC_OP_MODE. </dd></dl>

</div>
</div>
<a id="gac57d144b053a1c99018cea2e39b3a909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac57d144b053a1c99018cea2e39b3a909">&sect;&nbsp;</a></span>obtenirChaineGlMap1Color4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1Color4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_COLOR_4. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_COLOR_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates colors. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_COLOR_4. </dd></dl>

</div>
</div>
<a id="gaf763362cd94b7724001337e1d41e12fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf763362cd94b7724001337e1d41e12fe">&sect;&nbsp;</a></span>obtenirChaineGlMap1GridDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1GridDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_GRID_DOMAIN. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_GRID_DOMAIN.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the endpoints of the 1D map's grid domain. The initial value is (0, 1). See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_GRID_DOMAIN. </dd></dl>

</div>
</div>
<a id="ga8ee60c16c6bdb624d5ebc846ea3639d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ee60c16c6bdb624d5ebc846ea3639d7">&sect;&nbsp;</a></span>obtenirChaineGlMap1GridSegments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1GridSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_GRID_SEGMENTS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_GRID_SEGMENTS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of partitions in the 1D map's grid domain. The initial value is 1. See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_GRID_SEGMENTS. </dd></dl>

</div>
</div>
<a id="ga76838290be271e3afca8cbc5ead4370e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76838290be271e3afca8cbc5ead4370e">&sect;&nbsp;</a></span>obtenirChaineGlMap1Index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1Index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_INDEX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates color indices. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_INDEX. </dd></dl>

</div>
</div>
<a id="gab30e5c538d408bc25a8fe2c3abe024e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30e5c538d408bc25a8fe2c3abe024e8">&sect;&nbsp;</a></span>obtenirChaineGlMap1Normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1Normal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_NORMAL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates normals. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_NORMAL. </dd></dl>

</div>
</div>
<a id="gaea983353723427a58f4fdefd471b1682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea983353723427a58f4fdefd471b1682">&sect;&nbsp;</a></span>obtenirChaineGlMap1TextureCoord1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1TextureCoord1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_1. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_1.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 1D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_1. </dd></dl>

</div>
</div>
<a id="ga90439930d97788a4e754adadfe08412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90439930d97788a4e754adadfe08412f">&sect;&nbsp;</a></span>obtenirChaineGlMap1TextureCoord2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1TextureCoord2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_2. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_2.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 2D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_2. </dd></dl>

</div>
</div>
<a id="gac7abe6d7b529d6e26162093c0224a832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7abe6d7b529d6e26162093c0224a832">&sect;&nbsp;</a></span>obtenirChaineGlMap1TextureCoord3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1TextureCoord3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_3. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 3D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_3. </dd></dl>

</div>
</div>
<a id="ga7a3fec09fca2e0c6de37560cd148744c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a3fec09fca2e0c6de37560cd148744c">&sect;&nbsp;</a></span>obtenirChaineGlMap1TextureCoord4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1TextureCoord4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_4. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 4D texture coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_TEXTURE_COORD_4. </dd></dl>

</div>
</div>
<a id="ga8f3ed72498b4d68dbdbfe0e5a32e3a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f3ed72498b4d68dbdbfe0e5a32e3a40">&sect;&nbsp;</a></span>obtenirChaineGlMap1Vertex3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1Vertex3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_VERTEX_3. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_VERTEX_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 3D vertex coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_VERTEX_3. </dd></dl>

</div>
</div>
<a id="ga2c2f5633ecf15a85b63296a1e40b9191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c2f5633ecf15a85b63296a1e40b9191">&sect;&nbsp;</a></span>obtenirChaineGlMap1Vertex4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap1Vertex4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP1_VERTEX_4. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP1_VERTEX_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D evaluation generates 4D vertex coordinates. The initial value is GL_FALSE. See glMap1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP1_VERTEX_4. </dd></dl>

</div>
</div>
<a id="ga09a9ce4cd7f51dd9c8cbd70894556dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09a9ce4cd7f51dd9c8cbd70894556dc0">&sect;&nbsp;</a></span>obtenirChaineGlMap2Color4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2Color4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_COLOR_4. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_COLOR_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates colors. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_COLOR_4. </dd></dl>

</div>
</div>
<a id="ga4590606ccae7cdf8e98a79d497af46e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4590606ccae7cdf8e98a79d497af46e6">&sect;&nbsp;</a></span>obtenirChaineGlMap2GridDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2GridDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_GRID_DOMAIN. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_GRID_DOMAIN.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the endpoints of the 2D map's i and j grid domains. The initial value is (0,1; 0,1). See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_GRID_DOMAIN. </dd></dl>

</div>
</div>
<a id="ga384b4ac4bf1f142fd5dc8ec88d2c85fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga384b4ac4bf1f142fd5dc8ec88d2c85fc">&sect;&nbsp;</a></span>obtenirChaineGlMap2GridSegments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2GridSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_GRID_SEGMENTS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_GRID_SEGMENTS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the number of partitions in the 2D map's i and j grid domains. The initial value is (1,1). See glMapGrid.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_GRID_SEGMENTS. </dd></dl>

</div>
</div>
<a id="ga0bd7235c16eff55a23f25adcbf710911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bd7235c16eff55a23f25adcbf710911">&sect;&nbsp;</a></span>obtenirChaineGlMap2Index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2Index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_INDEX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_INDEX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates color indices. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_INDEX. </dd></dl>

</div>
</div>
<a id="ga1bbf15a19f4634a8257aeb9bb80eb20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bbf15a19f4634a8257aeb9bb80eb20e">&sect;&nbsp;</a></span>obtenirChaineGlMap2Normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2Normal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_NORMAL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_NORMAL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates normals. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_NORMAL. </dd></dl>

</div>
</div>
<a id="ga22bc858ecfeb91e6c841e6115a7082a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22bc858ecfeb91e6c841e6115a7082a6">&sect;&nbsp;</a></span>obtenirChaineGlMap2TextureCoord1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2TextureCoord1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_1. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_1.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 1D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_1. </dd></dl>

</div>
</div>
<a id="gaccaee7cbb411052f0d37e6751df9d8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccaee7cbb411052f0d37e6751df9d8ce">&sect;&nbsp;</a></span>obtenirChaineGlMap2TextureCoord2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2TextureCoord2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_2. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_2.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 2D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_2. </dd></dl>

</div>
</div>
<a id="ga878568aa4f6b5245643bfa8bb4867efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga878568aa4f6b5245643bfa8bb4867efd">&sect;&nbsp;</a></span>obtenirChaineGlMap2TextureCoord3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2TextureCoord3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_3. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 3D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_3. </dd></dl>

</div>
</div>
<a id="gaf4e5bb4869d4267c0e02ea534a48d375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4e5bb4869d4267c0e02ea534a48d375">&sect;&nbsp;</a></span>obtenirChaineGlMap2TextureCoord4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2TextureCoord4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_4. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 4D texture coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_TEXTURE_COORD_4. </dd></dl>

</div>
</div>
<a id="ga285c29858dbc4e903c5b4ff440db53e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga285c29858dbc4e903c5b4ff440db53e8">&sect;&nbsp;</a></span>obtenirChaineGlMap2Vertex3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2Vertex3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_VERTEX_3. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_VERTEX_3.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 3D vertex coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_VERTEX_3. </dd></dl>

</div>
</div>
<a id="ga39656da920c0d8514997f80f6a9cba9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39656da920c0d8514997f80f6a9cba9c">&sect;&nbsp;</a></span>obtenirChaineGlMap2Vertex4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMap2Vertex4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP2_VERTEX_4. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP2_VERTEX_4.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D evaluation generates 4D vertex coordinates. The initial value is GL_FALSE. See glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP2_VERTEX_4. </dd></dl>

</div>
</div>
<a id="gaa8d0322515459f98842327324d0df057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d0322515459f98842327324d0df057">&sect;&nbsp;</a></span>obtenirChaineGlMapColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMapColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP_COLOR. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP_COLOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating if colors and color indices are to be replaced by table lookup during pixel transfers. The initial value is GL_FALSE. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP_COLOR. </dd></dl>

</div>
</div>
<a id="ga81beffa94520d3e7a7d3ee04b3fd1f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81beffa94520d3e7a7d3ee04b3fd1f0b">&sect;&nbsp;</a></span>obtenirChaineGlMapStencil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMapStencil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAP_STENCIL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAP_STENCIL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating if stencil indices are to be replaced by table lookup during pixel transfers. The initial value is GL_FALSE. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAP_STENCIL. </dd></dl>

</div>
</div>
<a id="gaa23caf97a7f7733b6a2b1959fb63c7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa23caf97a7f7733b6a2b1959fb63c7c5">&sect;&nbsp;</a></span>obtenirChaineGlMatrixMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMatrixMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MATRIX_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MATRIX_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which matrix stack is currently the target of all matrix operations. The initial value is GL_MODELVIEW. See glMatrixMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MATRIX_MODE. </dd></dl>

</div>
</div>
<a id="ga050cc800f743296726f4bd93a756a6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga050cc800f743296726f4bd93a756a6da">&sect;&nbsp;</a></span>obtenirChaineGlMaxAttribStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the attribute stack. The value must be at least 16. See glPushAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="ga97547178b781217d7e84ab1efc8b03af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97547178b781217d7e84ab1efc8b03af">&sect;&nbsp;</a></span>obtenirChaineGlMaxClientAttribStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxClientAttribStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value indicating the maximum supported depth of the client attribute stack. See glPushClientAttrib.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_CLIENT_ATTRIB_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="gac6c9f2409548e8eb7777751869827fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6c9f2409548e8eb7777751869827fe1">&sect;&nbsp;</a></span>obtenirChaineGlMaxClipPlanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxClipPlanes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_CLIP_PLANES. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_CLIP_PLANES.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum number of application-defined clipping planes. The value must be at least 6. See glClipPlane.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_CLIP_PLANES. </dd></dl>

</div>
</div>
<a id="ga4eeb23cefd74c0ebe845d124ffca5ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eeb23cefd74c0ebe845d124ffca5ddb">&sect;&nbsp;</a></span>obtenirChaineGlMaxEvalOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxEvalOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_EVAL_ORDER. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_EVAL_ORDER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum equation order supported by 1D and 2D evaluators. The value must be at least 8. See glMap1 and glMap2.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_EVAL_ORDER. </dd></dl>

</div>
</div>
<a id="gaa3973a9be1964aefbdfc832bf5e81dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3973a9be1964aefbdfc832bf5e81dfe">&sect;&nbsp;</a></span>obtenirChaineGlMaxListNesting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxListNesting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_LIST_NESTING. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_LIST_NESTING.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum recursion depth allowed during display-list traversal. The value must be at least 64. See glCallList.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_LIST_NESTING. </dd></dl>

</div>
</div>
<a id="ga8f1220cb4537ba020af350dad3f4d338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f1220cb4537ba020af350dad3f4d338">&sect;&nbsp;</a></span>obtenirChaineGlMaxModelviewStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxModelviewStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the modelview matrix stack. The value must be at least 32. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_MODELVIEW_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="gacbf757dc312caa43735a22d8d05b30d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbf757dc312caa43735a22d8d05b30d8">&sect;&nbsp;</a></span>obtenirChaineGlMaxNameStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxNameStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_NAME_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_NAME_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the selection name stack. The value must be at least 64. See glPushName.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_NAME_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="gace88fdb9dc01b7e5338842cff2ed3654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace88fdb9dc01b7e5338842cff2ed3654">&sect;&nbsp;</a></span>obtenirChaineGlMaxPixelMapTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxPixelMapTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_PIXEL_MAP_TABLE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_PIXEL_MAP_TABLE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported size of a glPixelMap lookup table. The value must be at least 32. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_PIXEL_MAP_TABLE. </dd></dl>

</div>
</div>
<a id="ga9a7ce59e34f6586dc7a36fe549a9b012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7ce59e34f6586dc7a36fe549a9b012">&sect;&nbsp;</a></span>obtenirChaineGlMaxProjectionStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxProjectionStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_PROJECTION_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_PROJECTION_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the projection matrix stack. The value must be at least 2. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_PROJECTION_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="ga508ab9a35dcf52e881d71fe4d14118f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga508ab9a35dcf52e881d71fe4d14118f9">&sect;&nbsp;</a></span>obtenirChaineGlMaxTextureSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxTextureSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_TEXTURE_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_TEXTURE_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value. The value gives a rough estimate of the largest texture that the GL can handle. If the GL version is 1.1 or greater, use GL_PROXY_TEXTURE_1D or GL_PROXY_TEXTURE_2D to determine if a texture is too large. See glTexImage1D and glTexImage2D.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_TEXTURE_SIZE. </dd></dl>

</div>
</div>
<a id="ga04c9ebbbdfbb76ddcc6a93b166e9cddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04c9ebbbdfbb76ddcc6a93b166e9cddb">&sect;&nbsp;</a></span>obtenirChaineGlMaxTextureStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxTextureStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_TEXTURE_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_TEXTURE_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the maximum supported depth of the texture matrix stack. The value must be at least 2. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_TEXTURE_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="gaeb56f576ca5a4ce0cf7be52bc31f3573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb56f576ca5a4ce0cf7be52bc31f3573">&sect;&nbsp;</a></span>obtenirChaineGlMaxViewportDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlMaxViewportDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MAX_VIEWPORT_DIMS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MAX_VIEWPORT_DIMS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See glViewport.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MAX_VIEWPORT_DIMS. </dd></dl>

</div>
</div>
<a id="gaf1480b4822a921b229b58e861492f063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1480b4822a921b229b58e861492f063">&sect;&nbsp;</a></span>obtenirChaineGlModelviewMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlModelviewMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MODELVIEW_MATRIX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MODELVIEW_MATRIX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns sixteen values: the modelview matrix on the top of the modelview matrix stack. Initially this matrix is the identity matrix. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MODELVIEW_MATRIX. </dd></dl>

</div>
</div>
<a id="ga8040b27cf3e56f9a83eef63a194bbb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8040b27cf3e56f9a83eef63a194bbb08">&sect;&nbsp;</a></span>obtenirChaineGlModelviewStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlModelviewStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_MODELVIEW_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_MODELVIEW_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of matrices on the modelview matrix stack. The initial value is 1. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_MODELVIEW_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="gaf203b021376db7b8df969ede06af5d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf203b021376db7b8df969ede06af5d40">&sect;&nbsp;</a></span>obtenirChaineGlNameStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlNameStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_NAME_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_NAME_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of names on the selection name stack. The initial value is 0. See glPushName.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_NAME_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="ga4ce97d6b7493447f3a7758e991f44058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ce97d6b7493447f3a7758e991f44058">&sect;&nbsp;</a></span>obtenirChaineGlNormalArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlNormalArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value, indicating whether the normal array is enabled. The initial value is GL_FALSE. See glNormalPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_NORMAL_ARRAY. </dd></dl>

</div>
</div>
<a id="gaa3073f0f33864989bf26ec4773633713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3073f0f33864989bf26ec4773633713">&sect;&nbsp;</a></span>obtenirChaineGlNormalArrayStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlNormalArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive normals in the normal array. The initial value is 0. See glNormalPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_NORMAL_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a id="ga7635092692d14683acc8fd7c9a1a8181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7635092692d14683acc8fd7c9a1a8181">&sect;&nbsp;</a></span>obtenirChaineGlNormalArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlNormalArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_NORMAL_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of each coordinate in the normal array. The initial value is GL_FLOAT. See glNormalPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_NORMAL_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a id="ga8b456e82a37616498b7a1c894b8b308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b456e82a37616498b7a1c894b8b308c">&sect;&nbsp;</a></span>obtenirChaineGlNormalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlNormalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_NORMALIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_NORMALIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether normals are automatically scaled to unit length after they have been transformed to eye coordinates. The initial value is GL_FALSE. See glNormal.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_NORMALIZE. </dd></dl>

</div>
</div>
<a id="gaaa85adce47c7da66ee96dfa8d462a03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa85adce47c7da66ee96dfa8d462a03a">&sect;&nbsp;</a></span>obtenirChaineGlPackAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPackAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PACK_ALIGNMENT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PACK_ALIGNMENT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PACK_ALIGNMENT. </dd></dl>

</div>
</div>
<a id="ga78f6dcd0faaced3739699bbcd76b1c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f6dcd0faaced3739699bbcd76b1c71">&sect;&nbsp;</a></span>obtenirChaineGlPackLsbFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPackLsbFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PACK_LSB_FIRST. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PACK_LSB_FIRST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PACK_LSB_FIRST. </dd></dl>

</div>
</div>
<a id="ga55ad9e22422fc5697d2a70b2b2684d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ad9e22422fc5697d2a70b2b2684d63">&sect;&nbsp;</a></span>obtenirChaineGlPackRowLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPackRowLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PACK_ROW_LENGTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PACK_ROW_LENGTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the row length used for writing pixel data to memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PACK_ROW_LENGTH. </dd></dl>

</div>
</div>
<a id="ga8a242f17034ea2356363a1e0a4758c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a242f17034ea2356363a1e0a4758c90">&sect;&nbsp;</a></span>obtenirChaineGlPackSkipPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPackSkipPixels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PACK_SKIP_PIXELS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PACK_SKIP_PIXELS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PACK_SKIP_PIXELS. </dd></dl>

</div>
</div>
<a id="gab44b7fc6e446520ab2768d997f05a766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab44b7fc6e446520ab2768d997f05a766">&sect;&nbsp;</a></span>obtenirChaineGlPackSkipRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPackSkipRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PACK_SKIP_ROWS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PACK_SKIP_ROWS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PACK_SKIP_ROWS. </dd></dl>

</div>
</div>
<a id="ga9ab7a4474cc998f813c9e628fcd3cc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ab7a4474cc998f813c9e628fcd3cc2a">&sect;&nbsp;</a></span>obtenirChaineGlPackSwapBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPackSwapBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PACK_SWAP_BYTES. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PACK_SWAP_BYTES.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PACK_SWAP_BYTES. </dd></dl>

</div>
</div>
<a id="gaa12b3f79146d08ef8b3bafa9e4b93886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa12b3f79146d08ef8b3bafa9e4b93886">&sect;&nbsp;</a></span>obtenirChaineGlPerspectiveCorrectionHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPerspectiveCorrectionHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PERSPECTIVE_CORRECTION_HINT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PERSPECTIVE_CORRECTION_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the perspective correction hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PERSPECTIVE_CORRECTION_HINT. </dd></dl>

</div>
</div>
<a id="ga9b02a331655953bb9fd872ba2fee3562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b02a331655953bb9fd872ba2fee3562">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapAToASize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapAToASize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the alpha-to-alpha pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_A_TO_A_SIZE. </dd></dl>

</div>
</div>
<a id="ga5fc081b3862bbe1cb5a5038d9bab83ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fc081b3862bbe1cb5a5038d9bab83ed">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapBToBSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapBToBSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the blue-to-blue pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_B_TO_B_SIZE. </dd></dl>

</div>
</div>
<a id="ga4bc643dc88cf9ef2805ba8d36ae78204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc643dc88cf9ef2805ba8d36ae78204">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapGToGSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapGToGSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the green-to-green pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_G_TO_G_SIZE. </dd></dl>

</div>
</div>
<a id="ga0746cb24bca308640dc74b50936572d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0746cb24bca308640dc74b50936572d1">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapIToASize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapIToASize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-alpha pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_A_SIZE. </dd></dl>

</div>
</div>
<a id="ga9c2c0672eee401a0a4b68f498135018c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c2c0672eee401a0a4b68f498135018c">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapIToBSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapIToBSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-blue pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_B_SIZE. </dd></dl>

</div>
</div>
<a id="gaa04b44bd5fb37682122f9706cae79ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04b44bd5fb37682122f9706cae79ce7">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapIToGSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapIToGSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-green pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_G_SIZE. </dd></dl>

</div>
</div>
<a id="ga5383c7a5bae41cf7d3303ceb9cf582bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5383c7a5bae41cf7d3303ceb9cf582bf">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapIToISize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapIToISize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-index pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_I_SIZE. </dd></dl>

</div>
</div>
<a id="ga9d54f0be62b1259f9497c5840ec1464d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d54f0be62b1259f9497c5840ec1464d">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapIToRSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapIToRSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the index-to-red pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_I_TO_R_SIZE. </dd></dl>

</div>
</div>
<a id="gaf773e5f5e598b47fa22088144ca761d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf773e5f5e598b47fa22088144ca761d1">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapRToRSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapRToRSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the red-to-red pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_R_TO_R_SIZE. </dd></dl>

</div>
</div>
<a id="gaa5706b973e085773d950078b78a2b620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5706b973e085773d950078b78a2b620">&sect;&nbsp;</a></span>obtenirChaineGlPixelMapSToSSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPixelMapSToSSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size of the stencil-to-stencil pixel translation table. The initial value is 1. See glPixelMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PIXEL_MAP_S_TO_S_SIZE. </dd></dl>

</div>
</div>
<a id="gad7b174cc2333e6c33bfc51799c6b2c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b174cc2333e6c33bfc51799c6b2c12">&sect;&nbsp;</a></span>obtenirChaineGlPointSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPointSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POINT_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POINT_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the point size as specified by glPointSize. The initial value is 1.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POINT_SIZE. </dd></dl>

</div>
</div>
<a id="gac88a08fbe834fcf661f5998c66db80f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac88a08fbe834fcf661f5998c66db80f4">&sect;&nbsp;</a></span>obtenirChaineGlPointSizeGranularity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPointSizeGranularity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POINT_SIZE_GRANULARITY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POINT_SIZE_GRANULARITY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the size difference between adjacent supported sizes for antialiased points. See glPointSize.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POINT_SIZE_GRANULARITY. </dd></dl>

</div>
</div>
<a id="gaf87ef6371391b2e7ba77107bfe492dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf87ef6371391b2e7ba77107bfe492dbb">&sect;&nbsp;</a></span>obtenirChaineGlPointSizeRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPointSizeRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POINT_SIZE_RANGE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POINT_SIZE_RANGE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See glPointSize.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POINT_SIZE_RANGE. </dd></dl>

</div>
</div>
<a id="gaffd0c8209c85b0a1cf4b5fa9413fcd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffd0c8209c85b0a1cf4b5fa9413fcd1a">&sect;&nbsp;</a></span>obtenirChaineGlPointSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPointSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POINT_SMOOTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POINT_SMOOTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether antialiasing of points is enabled. The initial value is GL_FALSE. See glPointSize.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POINT_SMOOTH. </dd></dl>

</div>
</div>
<a id="gab166c857613b362db6dc0e2d420febe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab166c857613b362db6dc0e2d420febe5">&sect;&nbsp;</a></span>obtenirChaineGlPointSmoothHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPointSmoothHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POINT_SMOOTH_HINT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POINT_SMOOTH_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the point antialiasing hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POINT_SMOOTH_HINT. </dd></dl>

</div>
</div>
<a id="ga05467477ba232dd5fcd36e17b8d40385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05467477ba232dd5fcd36e17b8d40385">&sect;&nbsp;</a></span>obtenirChaineGlPolygonMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns two values: symbolic constants indicating whether front-facing and back-facing polygons are rasterized as points, lines, or filled polygons. The initial value is GL_FILL. See glPolygonMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_MODE. </dd></dl>

</div>
</div>
<a id="ga59e23b892dccca468bc208aa64505dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e23b892dccca468bc208aa64505dbd">&sect;&nbsp;</a></span>obtenirChaineGlPolygonOffsetFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonOffsetFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_FACTOR. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_FACTOR.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_OFFSET_FACTOR. </dd></dl>

</div>
</div>
<a id="ga1c75b08296744c8c67c75e3061377b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c75b08296744c8c67c75e3061377b8a">&sect;&nbsp;</a></span>obtenirChaineGlPolygonOffsetFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonOffsetFill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_FILL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_FILL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is GL_FALSE. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_OFFSET_FILL. </dd></dl>

</div>
</div>
<a id="gab655913662359133d622e393aa3b9ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab655913662359133d622e393aa3b9ba7">&sect;&nbsp;</a></span>obtenirChaineGlPolygonOffsetLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonOffsetLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_LINE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_LINE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is GL_FALSE. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_OFFSET_LINE. </dd></dl>

</div>
</div>
<a id="ga55c86fd41a6399f87d2bbb9adf200325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55c86fd41a6399f87d2bbb9adf200325">&sect;&nbsp;</a></span>obtenirChaineGlPolygonOffsetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonOffsetPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_POINT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_POINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is GL_FALSE. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_OFFSET_POINT. </dd></dl>

</div>
</div>
<a id="gafdfa2ace0eaa2cd2f5e4b773e16b27fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfa2ace0eaa2cd2f5e4b773e16b27fe">&sect;&nbsp;</a></span>obtenirChaineGlPolygonOffsetUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonOffsetUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_UNITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_OFFSET_UNITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See glPolygonOffset.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_OFFSET_UNITS. </dd></dl>

</div>
</div>
<a id="ga2369a9f60619021a9df5aae539435bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2369a9f60619021a9df5aae539435bc3">&sect;&nbsp;</a></span>obtenirChaineGlPolygonSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_SMOOTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_SMOOTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is GL_FALSE. See glPolygonMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_SMOOTH. </dd></dl>

</div>
</div>
<a id="ga87309eb95b99cdb1711f1c1fa2394f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87309eb95b99cdb1711f1c1fa2394f0d">&sect;&nbsp;</a></span>obtenirChaineGlPolygonSmoothHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonSmoothHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_SMOOTH_HINT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_SMOOTH_HINT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is GL_DONT_CARE. See glHint.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_SMOOTH_HINT. </dd></dl>

</div>
</div>
<a id="ga14e2e465a5c151e2fff64f3e7f12fef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14e2e465a5c151e2fff64f3e7f12fef3">&sect;&nbsp;</a></span>obtenirChaineGlPolygonStipple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlPolygonStipple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_POLYGON_STIPPLE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_POLYGON_STIPPLE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether polygon stippling is enabled. The initial value is GL_FALSE. See glPolygonStipple.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_POLYGON_STIPPLE. </dd></dl>

</div>
</div>
<a id="ga40c176113dd3186a52270079433680b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c176113dd3186a52270079433680b9">&sect;&nbsp;</a></span>obtenirChaineGlProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlProjectionMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PROJECTION_MATRIX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PROJECTION_MATRIX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns sixteen values: the projection matrix on the top of the projection matrix stack. Initially this matrix is the identity matrix. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PROJECTION_MATRIX. </dd></dl>

</div>
</div>
<a id="ga4a8f030d737a1f7fb5a34ad866cfebb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a8f030d737a1f7fb5a34ad866cfebb4">&sect;&nbsp;</a></span>obtenirChaineGlProjectionStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlProjectionStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_PROJECTION_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_PROJECTION_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of matrices on the projection matrix stack. The initial value is 1. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_PROJECTION_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="gaf2de1c0bd2290f8a19abcf2437ebd150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2de1c0bd2290f8a19abcf2437ebd150">&sect;&nbsp;</a></span>obtenirChaineGlReadBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlReadBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_READ_BUFFER. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_READ_BUFFER.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is GL_BACK if there is a back buffer, otherwise it is GL_FRONT. See glReadPixels and glAccum.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_READ_BUFFER. </dd></dl>

</div>
</div>
<a id="ga06eff0093b19074897fd133ed367d9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06eff0093b19074897fd133ed367d9ff">&sect;&nbsp;</a></span>obtenirChaineGlRedBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlRedBias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_RED_BIAS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_RED_BIAS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the red bias factor used during pixel transfers. The initial value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_RED_BIAS. </dd></dl>

</div>
</div>
<a id="gad56a19dc9a4529bef6aa2c554feda890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56a19dc9a4529bef6aa2c554feda890">&sect;&nbsp;</a></span>obtenirChaineGlRedBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlRedBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_RED_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_RED_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of red bitplanes in each color buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_RED_BITS. </dd></dl>

</div>
</div>
<a id="ga52067c6e1d8fa44b48bf4dd810701a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52067c6e1d8fa44b48bf4dd810701a15">&sect;&nbsp;</a></span>obtenirChaineGlRedScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlRedScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_RED_SCALE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_RED_SCALE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the red scale factor used during pixel transfers. The initial value is 1. See glPixelTransfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_RED_SCALE. </dd></dl>

</div>
</div>
<a id="gaf2eb228c03ceca3464a9e83d2023f492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2eb228c03ceca3464a9e83d2023f492">&sect;&nbsp;</a></span>obtenirChaineGlRenderMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlRenderMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_RENDER_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_RENDER_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating whether the GL is in render, select, or feedback mode. The initial value is GL_RENDER. See glRenderMode.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_RENDER_MODE. </dd></dl>

</div>
</div>
<a id="ga8c76be29c24d6171080188bd786307c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c76be29c24d6171080188bd786307c8">&sect;&nbsp;</a></span>obtenirChaineGlRgbaMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlRgbaMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_RGBA_MODE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_RGBA_MODE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the GL is in RGBA mode (true) or color index mode (false). See glColor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_RGBA_MODE. </dd></dl>

</div>
</div>
<a id="ga5397b24eddfea01b757f86500e01ca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5397b24eddfea01b757f86500e01ca91">&sect;&nbsp;</a></span>obtenirChaineGlScissorBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlScissorBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_SCISSOR_BOX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_SCISSOR_BOX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the x and y window coordinates of the scissor box, followed by its width and height. Initially the x and y window coordinates are both 0 and the width and height are set to the size of the window. See glScissor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_SCISSOR_BOX. </dd></dl>

</div>
</div>
<a id="ga94f2d3e07f847eebf09f5a1887cebf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f2d3e07f847eebf09f5a1887cebf31">&sect;&nbsp;</a></span>obtenirChaineGlScissorTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlScissorTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_SCISSOR_TEST. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_SCISSOR_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether scissoring is enabled. The initial value is GL_FALSE. See glScissor.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_SCISSOR_TEST. </dd></dl>

</div>
</div>
<a id="ga92126b4a8c29117620315ed25f1ecc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92126b4a8c29117620315ed25f1ecc63">&sect;&nbsp;</a></span>obtenirChaineGlSelectionBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlSelectionBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_SELECTION_BUFFER_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_SELECTION_BUFFER_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params return one value, the size of the selection buffer. See glSelectBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_SELECTION_BUFFER_SIZE. </dd></dl>

</div>
</div>
<a id="gab3a76a5d09a39eb621b569461e91e858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a76a5d09a39eb621b569461e91e858">&sect;&nbsp;</a></span>obtenirChaineGlShadeModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlShadeModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_SHADE_MODEL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_SHADE_MODEL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating whether the shading mode is flat or smooth. The initial value is GL_SMOOTH. See glShadeModel.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_SHADE_MODEL. </dd></dl>

</div>
</div>
<a id="gaf1345260afe74206391e4135d00fcb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1345260afe74206391e4135d00fcb63">&sect;&nbsp;</a></span>obtenirChaineGlStencilBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of bitplanes in the stencil buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_BITS. </dd></dl>

</div>
</div>
<a id="gaab3af85b29e73001331e92b27d192fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab3af85b29e73001331e92b27d192fb7">&sect;&nbsp;</a></span>obtenirChaineGlStencilClearValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilClearValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_CLEAR_VALUE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_CLEAR_VALUE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See glClearStencil.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_CLEAR_VALUE. </dd></dl>

</div>
</div>
<a id="ga923a65eef9235ac8b0a443e05c9f5c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga923a65eef9235ac8b0a443e05c9f5c5a">&sect;&nbsp;</a></span>obtenirChaineGlStencilFail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilFail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_FAIL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_FAIL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is GL_KEEP. See glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_FAIL. </dd></dl>

</div>
</div>
<a id="gac52b8984d0924fa3d0d05b63b67b46e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac52b8984d0924fa3d0d05b63b67b46e8">&sect;&nbsp;</a></span>obtenirChaineGlStencilFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_FUNC. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_FUNC.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is GL_ALWAYS. See glStencilFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_FUNC. </dd></dl>

</div>
</div>
<a id="ga5e43430a722833aa85b377b40cbfaf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e43430a722833aa85b377b40cbfaf2c">&sect;&nbsp;</a></span>obtenirChaineGlStencilPassDepthFail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilPassDepthFail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_FAIL. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_FAIL.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is GL_KEEP. See glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_FAIL. </dd></dl>

</div>
</div>
<a id="gade8c552e1ab102d594f33dc42e24b15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade8c552e1ab102d594f33dc42e24b15c">&sect;&nbsp;</a></span>obtenirChaineGlStencilPassDepthPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilPassDepthPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_PASS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_PASS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is GL_KEEP. See glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_PASS_DEPTH_PASS. </dd></dl>

</div>
</div>
<a id="ga277fcf055256635d9b1805280ec3cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga277fcf055256635d9b1805280ec3cbc3">&sect;&nbsp;</a></span>obtenirChaineGlStencilRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_REF. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_REF.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See glStencilFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_REF. </dd></dl>

</div>
</div>
<a id="gaed31aaa16c09247896df7b92d9552655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed31aaa16c09247896df7b92d9552655">&sect;&nbsp;</a></span>obtenirChaineGlStencilTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_TEST. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_TEST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is GL_FALSE. See glStencilFunc and glStencilOp.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_TEST. </dd></dl>

</div>
</div>
<a id="ga6cbf8f4a60d17db09c4f68535c7f70fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cbf8f4a60d17db09c4f68535c7f70fc">&sect;&nbsp;</a></span>obtenirChaineGlStencilValueMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilValueMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_VALUE_MASK. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_VALUE_MASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See glStencilFunc.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_VALUE_MASK. </dd></dl>

</div>
</div>
<a id="ga1dd84c41a78ec45d41bc97b95a15f9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd84c41a78ec45d41bc97b95a15f9fc">&sect;&nbsp;</a></span>obtenirChaineGlStencilWritemask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStencilWritemask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STENCIL_WRITEMASK. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STENCIL_WRITEMASK.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See glStencilMask.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STENCIL_WRITEMASK. </dd></dl>

</div>
</div>
<a id="ga77baae4c5b5df2f3e76b062b2862f920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77baae4c5b5df2f3e76b062b2862f920">&sect;&nbsp;</a></span>obtenirChaineGlStereo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlStereo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_STEREO. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_STEREO.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether stereo buffers (left and right) are supported.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_STEREO. </dd></dl>

</div>
</div>
<a id="ga0a003ccc8f459a98d31b336082d12960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a003ccc8f459a98d31b336082d12960">&sect;&nbsp;</a></span>obtenirChaineGlSubpixelBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlSubpixelBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_SUBPIXEL_BITS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_SUBPIXEL_BITS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The initial value is 4.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_SUBPIXEL_BITS. </dd></dl>

</div>
</div>
<a id="ga2ecac3a1ee37165021792ff4ef273b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ecac3a1ee37165021792ff4ef273b89">&sect;&nbsp;</a></span>obtenirChaineGlTexture1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTexture1D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_1D. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_1D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 1D texture mapping is enabled. The initial value is GL_FALSE. See glTexImage1D.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_1D. </dd></dl>

</div>
</div>
<a id="ga156f1a8be92219db140f7c1daca8a2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156f1a8be92219db140f7c1daca8a2b5">&sect;&nbsp;</a></span>obtenirChaineGlTexture2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTexture2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_2D. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_2D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether 2D texture mapping is enabled. The initial value is GL_FALSE. See glTexImage2D.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_2D. </dd></dl>

</div>
</div>
<a id="gacea59e236a466ac41b9130f12f5c5a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacea59e236a466ac41b9130f12f5c5a6e">&sect;&nbsp;</a></span>obtenirChaineGlTextureBinding1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureBinding1D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_BINDING_1D. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_BINDING_1D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single value, the name of the texture currently bound to the target GL_TEXTURE_1D. The initial value is 0. See glBindTexture.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_BINDING_1D. </dd></dl>

</div>
</div>
<a id="ga87ae24572f99408cb84c1571e6cae72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ae24572f99408cb84c1571e6cae72e">&sect;&nbsp;</a></span>obtenirChaineGlTextureBinding2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureBinding2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_BINDING_2D. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_BINDING_2D.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single value, the name of the texture currently bound to the target GL_TEXTURE_2D. The initial value is 0. See glBindTexture.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_BINDING_2D. </dd></dl>

</div>
</div>
<a id="ga07c00f3420ee159b23e0e102b7948d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c00f3420ee159b23e0e102b7948d4a">&sect;&nbsp;</a></span>obtenirChaineGlTextureCoordArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureCoordArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the texture coordinate array is enabled. The initial value is GL_FALSE. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY. </dd></dl>

</div>
</div>
<a id="ga7468bc8b89c05868239f4f53ec84cf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7468bc8b89c05868239f4f53ec84cf7a">&sect;&nbsp;</a></span>obtenirChaineGlTextureCoordArraySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureCoordArraySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of coordinates per element in the texture coordinate array. The initial value is 4. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_SIZE. </dd></dl>

</div>
</div>
<a id="ga97a9abaf5f85c142d16fb58c00a25b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97a9abaf5f85c142d16fb58c00a25b51">&sect;&nbsp;</a></span>obtenirChaineGlTextureCoordArrayStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureCoordArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive elements in the texture coordinate array. The initial value is 0. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a id="ga6d6fb5e06dce2c10c5066cb94f5f481e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d6fb5e06dce2c10c5066cb94f5f481e">&sect;&nbsp;</a></span>obtenirChaineGlTextureCoordArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureCoordArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of the coordinates in the texture coordinate array. The initial value is GL_FLOAT. See glTexCoordPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_COORD_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a id="ga0a34df2187456533ca64fb547c3c4290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a34df2187456533ca64fb547c3c4290">&sect;&nbsp;</a></span>obtenirChaineGlTextureGenQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureGenQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_Q. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_Q.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the q texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_GEN_Q. </dd></dl>

</div>
</div>
<a id="ga42023690076a0152885688263ca95a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42023690076a0152885688263ca95a09">&sect;&nbsp;</a></span>obtenirChaineGlTextureGenR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureGenR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_R. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_R.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the r texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_GEN_R. </dd></dl>

</div>
</div>
<a id="gab72cdc9bcc2a13d27b00cde994d4b458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab72cdc9bcc2a13d27b00cde994d4b458">&sect;&nbsp;</a></span>obtenirChaineGlTextureGenS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureGenS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_S. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_S.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the S texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_GEN_S. </dd></dl>

</div>
</div>
<a id="ga38aadd8bf15030bf34dc675c25e290b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38aadd8bf15030bf34dc675c25e290b1">&sect;&nbsp;</a></span>obtenirChaineGlTextureGenT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureGenT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_T. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_GEN_T.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether automatic generation of the T texture coordinate is enabled. The initial value is GL_FALSE. See glTexGen.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_GEN_T. </dd></dl>

</div>
</div>
<a id="gaf136718e2ddd7373a9ddb2e00a636668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf136718e2ddd7373a9ddb2e00a636668">&sect;&nbsp;</a></span>obtenirChaineGlTextureMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_MATRIX. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_MATRIX.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns sixteen values: the texture matrix on the top of the texture matrix stack. Initially this matrix is the identity matrix. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_MATRIX. </dd></dl>

</div>
</div>
<a id="ga3c0088db61ba425e00e242226c23eba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c0088db61ba425e00e242226c23eba0">&sect;&nbsp;</a></span>obtenirChaineGlTextureStackDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlTextureStackDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_TEXTURE_STACK_DEPTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_TEXTURE_STACK_DEPTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of matrices on the texture matrix stack. The initial value is 1. See glPushMatrix.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_TEXTURE_STACK_DEPTH. </dd></dl>

</div>
</div>
<a id="gafa90f70671fa28856396c42bed13d3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa90f70671fa28856396c42bed13d3bb">&sect;&nbsp;</a></span>obtenirChaineGlUnpackAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlUnpackAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_UNPACK_ALIGNMENT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_UNPACK_ALIGNMENT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_UNPACK_ALIGNMENT. </dd></dl>

</div>
</div>
<a id="gae116760ea6ac4fcbe0066a1754459255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae116760ea6ac4fcbe0066a1754459255">&sect;&nbsp;</a></span>obtenirChaineGlUnpackLsbFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlUnpackLsbFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_UNPACK_LSB_FIRST. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_UNPACK_LSB_FIRST.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_UNPACK_LSB_FIRST. </dd></dl>

</div>
</div>
<a id="ga2e1a047daef580289cc434ac07334cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e1a047daef580289cc434ac07334cf4">&sect;&nbsp;</a></span>obtenirChaineGlUnpackRowLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlUnpackRowLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_UNPACK_ROW_LENGTH. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_UNPACK_ROW_LENGTH.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the row length used for reading pixel data from memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_UNPACK_ROW_LENGTH. </dd></dl>

</div>
</div>
<a id="gaf3c1baab4bf7aec317569d7f01792de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c1baab4bf7aec317569d7f01792de4">&sect;&nbsp;</a></span>obtenirChaineGlUnpackSkipPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlUnpackSkipPixels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_UNPACK_SKIP_PIXELS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_UNPACK_SKIP_PIXELS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_UNPACK_SKIP_PIXELS. </dd></dl>

</div>
</div>
<a id="ga1a3852f51ffcf4b7244315ffc7f1e5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a3852f51ffcf4b7244315ffc7f1e5e7">&sect;&nbsp;</a></span>obtenirChaineGlUnpackSkipRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlUnpackSkipRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_UNPACK_SKIP_ROWS. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_UNPACK_SKIP_ROWS.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_UNPACK_SKIP_ROWS. </dd></dl>

</div>
</div>
<a id="ga6d5f3633b0778ee675f5c6dcd8ce02c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d5f3633b0778ee675f5c6dcd8ce02c8">&sect;&nbsp;</a></span>obtenirChaineGlUnpackSwapBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlUnpackSwapBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_UNPACK_SWAP_BYTES. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_UNPACK_SWAP_BYTES.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is GL_FALSE. See glPixelStore.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_UNPACK_SWAP_BYTES. </dd></dl>

</div>
</div>
<a id="ga296737a05545afeefee6e3ff51fb9e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga296737a05545afeefee6e3ff51fb9e9f">&sect;&nbsp;</a></span>obtenirChaineGlVertexArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlVertexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns a single boolean value indicating whether the vertex array is enabled. The initial value is GL_FALSE. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_VERTEX_ARRAY. </dd></dl>

</div>
</div>
<a id="gace0230641b16e7addfb173d0bb2225f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0230641b16e7addfb173d0bb2225f3">&sect;&nbsp;</a></span>obtenirChaineGlVertexArraySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlVertexArraySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_SIZE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_SIZE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the number of coordinates per vertex in the vertex array. The initial value is 4. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_VERTEX_ARRAY_SIZE. </dd></dl>

</div>
</div>
<a id="ga720b3bc40a5ef124578f525b8f1e708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga720b3bc40a5ef124578f525b8f1e708f">&sect;&nbsp;</a></span>obtenirChaineGlVertexArrayStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlVertexArrayStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_STRIDE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_STRIDE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the byte offset between consecutive vertices in the vertex array. The initial value is 0. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_VERTEX_ARRAY_STRIDE. </dd></dl>

</div>
</div>
<a id="gaddbd22deaf3a7f5e0af66a3b0145a05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddbd22deaf3a7f5e0af66a3b0145a05f">&sect;&nbsp;</a></span>obtenirChaineGlVertexArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlVertexArrayType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_TYPE. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_VERTEX_ARRAY_TYPE.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the data type of each coordinate in the vertex array. The initial value is GL_FLOAT. See glVertexPointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_VERTEX_ARRAY_TYPE. </dd></dl>

</div>
</div>
<a id="ga24ecb164eb134e30a37a9928ea2a0e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ecb164eb134e30a37a9928ea2a0e93">&sect;&nbsp;</a></span>obtenirChaineGlViewport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_VIEWPORT. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_VIEWPORT.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns four values: the x and y window coordinates of the viewport, followed by its width and height. Initially the x and y window coordinates are both set to 0, and the width and height are set to the width and height of the window into which the GL will do its rendering. See glViewport.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_VIEWPORT. </dd></dl>

</div>
</div>
<a id="gafa724bf6cfbd4b0401c41c854ff06fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa724bf6cfbd4b0401c41c854ff06fcd">&sect;&nbsp;</a></span>obtenirChaineGlZoomX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlZoomX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ZOOM_X. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ZOOM_X.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the x pixel zoom factor. The initial value is 1. See glPixelZoom.</p>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ZOOM_X. </dd></dl>

</div>
</div>
<a id="ga87d07131212785e91285ea82bbba15f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d07131212785e91285ea82bbba15f7">&sect;&nbsp;</a></span>obtenirChaineGlZoomY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineGlZoomY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne une chaîne représentant l'attribut GL_ZOOM_Y. </p>
<p>Cette fonction retourne une chaîne représentant l'attribut GL_ZOOM_Y.</p>
<p>Selon le man page, cet attribut:</p>
<p>params returns one value, the $y$ pixel zoom factor. The initial value is</p><ol type="1">
<li>See glPixelZoom.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant l'attribut GL_ZOOM_Y. </dd></dl>

</div>
</div>
<a id="ga37fa66cf904b19e12643fa88cc8ee5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fa66cf904b19e12643fa88cc8ee5d5">&sect;&nbsp;</a></span>obtenirChaineVecteur()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string EtatOpenGL::obtenirChaineVecteur </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fonction qui retourne la chaîne d'un vecteur de valeurs. </p>
<p>Cette fonction retourne une chaîne représentant un attribut qui est un tableau.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: Le tableau d'attributs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>: Le nombre d'attributs dans le tableau.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Une chaîne représentant le tableau d'attributs. </dd></dl>

</div>
</div>
<a id="ga24ddfdab3e65cc4069b86ba84d3f565b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24ddfdab3e65cc4069b86ba84d3f565b">&sect;&nbsp;</a></span>obtenirDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EtatOpenGL::obtenirDifference </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;&#160;</td>
          <td class="paramname"><em>etat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;&#160;</td>
          <td class="paramname"><em>etat2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare deux états <a class="el" href="namespace_open_g_l.html">OpenGL</a> et affiche la différence entre les deux. </p>
<p>Cet opérateur permet d'afficher l'état <a class="el" href="namespace_open_g_l.html">OpenGL</a> sous une forme lisible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: Le flux de sortie. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etat1</td><td>: Le premier état <a class="el" href="namespace_open_g_l.html">OpenGL</a> de la comparaison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etat2</td><td>: Le second état <a class="el" href="namespace_open_g_l.html">OpenGL</a> de la comparaison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le flux de sortie. </dd></dl>

</div>
</div>
<a id="ga349c289d77c484b8b4a180843d968b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga349c289d77c484b8b4a180843d968b46">&sect;&nbsp;</a></span>obtenirInstance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_singleton.html">Singleton</a>&lt; T &gt;::obtenirInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtient l'instance unique de la classe. </p>
<p>Cette fonction retourne l'instance unique de la classe. Si l'instance n'existe pas, elle est créée. Ainsi, une seule instance sera créée. Cette fonction n'est pas "thread-safe".</p>
<dl class="section return"><dt>Returns</dt><dd>L'instance unique de la classe. </dd></dl>

</div>
</div>
<a id="ga3eb1e87955cdb70cd0b16f217740326b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb1e87955cdb70cd0b16f217740326b">&sect;&nbsp;</a></span>operator<() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &lt; pour une variable de type <em>std::string</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: La variable de type <em>std::string</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga04922202c65ecfea992b139fa3ad19ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04922202c65ecfea992b139fa3ad19ff">&sect;&nbsp;</a></span>operator<() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &lt; pour une variable de type <em>double</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>double</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga616de7f95d66959d1a2e3216143180aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga616de7f95d66959d1a2e3216143180aa">&sect;&nbsp;</a></span>operator<() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &lt; pour une variable de type <em>float</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>float</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga1c0af1c4869b15575ea9c9567a377776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c0af1c4869b15575ea9c9567a377776">&sect;&nbsp;</a></span>operator<() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &lt; pour une variable de type <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="gaa4c96e2902dbd2e7fc766683ae7dd3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c96e2902dbd2e7fc766683ae7dd3a0">&sect;&nbsp;</a></span>operator<() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &lt; pour une variable de type <em>unsigned</em> <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>unsigned</em> <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga2df50a83cca6bbfec35053d1b3f08a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df50a83cca6bbfec35053d1b3f08a83">&sect;&nbsp;</a></span>operator<() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &lt; pour une variable de type <em>char</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>char</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga5e7baf907cb1eec95df25008219c34f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7baf907cb1eec95df25008219c34f7">&sect;&nbsp;</a></span>operator<() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_ecriture_fichier_binaire.html">CEcritureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &lt; pour une variable de type <em>bool</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: La variable de type <em>bool</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga07715cf8ba84aab7a025770804188a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07715cf8ba84aab7a025770804188a24">&sect;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_etat_open_g_l.html">EtatOpenGL</a> &amp;&#160;</td>
          <td class="paramname"><em>etat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cet opérateur permet d'afficher l'état <a class="el" href="namespace_open_g_l.html">OpenGL</a> sous une forme lisible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: Le flux de sortie. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">etat</td><td>: L'état <a class="el" href="namespace_open_g_l.html">OpenGL</a> à afficher.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le flux de sortie. </dd></dl>

</div>
</div>
<a id="ga810bf15b405f05f3069b97084f61aa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga810bf15b405f05f3069b97084f61aa95">&sect;&nbsp;</a></span>operator>() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &gt; pour une variable de type <em>std::string</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>: La variable de type <em>std:string</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga3286b1bfce354ab81b9c5e16318f3726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3286b1bfce354ab81b9c5e16318f3726">&sect;&nbsp;</a></span>operator>() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &gt; pour une variable de type <em>double</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>double</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga66a0bc917393930593341bc27a7fa51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a0bc917393930593341bc27a7fa51d">&sect;&nbsp;</a></span>operator>() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &gt; pour une variable de type <em>float</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>float</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga06cd33d9234f45523dd443b122d897fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cd33d9234f45523dd443b122d897fa">&sect;&nbsp;</a></span>operator>() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &gt; pour une variable de type <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="gaf02d6718459c6e38d1ef0350b209da02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02d6718459c6e38d1ef0350b209da02">&sect;&nbsp;</a></span>operator>() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &gt; pour une variable de type <em>unsigned</em> <em>int</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>unsigned</em> <em>int</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga81285ae431b1fa84429945395a36f8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81285ae431b1fa84429945395a36f8ce">&sect;&nbsp;</a></span>operator>() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &gt; pour une variable de type <em>char</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>char</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
<a id="ga1585cce945bae21c66998f92f175b115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1585cce945bae21c66998f92f175b115">&sect;&nbsp;</a></span>operator>() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_lecture_fichier_binaire.html">CLectureFichierBinaire</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Surcharge de l'opérateur &gt; pour une variable de type <em>bool</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: L'objet représentant le fichier binaire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: La variable de type <em>bool</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'objet représentant le fichier binaire. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
